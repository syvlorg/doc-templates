#+setupfile: ./settings.org
#+include: ./settings.org

* lib
** eyedropper.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; eyedropper.el --- Pick foreground and background colors at cursor or pointer.
;;
;; Filename: eyedropper.el
;; Description: Pick foreground and background colors at cursor or pointer.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2006-2018, Drew Adams, all rights reserved.
;; Created: Fri Jun 23 08:07:15 2006
;; Version: 0
;; Package-Requires: ((hexrgb "0"))
;; Last-Updated: Mon Jan  1 11:15:31 2018 (-0800)
;;           By: dradams
;;     Update #: 200
;; URL: https://www.emacswiki.org/emacs/download/eyedropper.el
;; Doc URL: https://www.emacswiki.org/emacs/CustomizingFaces
;; Keywords: color, rgb, hsv, hexadecimal, face, frame
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `hexrgb'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  Use the commands defined here to examine or save the background or
;;  foreground color at the text cursor or the mouse pointer.
;;
;;  After using commands `eyedrop-pick-background-*' or
;;  `eyedrop-pick-foreground-*', the picked color is saved in variable
;;  `eyedrop-picked-background' or `eyedrop-picked-foreground',
;;  respectively.
;;
;;  If you have Emacs 22 or later, all of the functionality provided
;;  here, and much more, is provided in library `palette.el'.  Use
;;  library `eyedropper' instead of `palette.el' if either of these
;;  applies:
;;
;;  * You do not want to use the color palette itself.  You want only
;;    the functionality provided by `eyedropper.el'.
;;
;;  * Your Emacs version is older than Emacs 22 (`palette.el' requires
;;    22 or later).
;;
;;  If you load `palette.el', there is no reason to also load
;;  `eyedropper.el'.  However, if for some reason you do load both
;;  `palette.el' and `eyedropper.el' then load `palette.el' second, so
;;  that its definitions will override those provided in
;;  `eyedropper.el', providing additional functionality for the color
;;  palette.
;;
;;  To use this library:
;;
;;    Add this to your initialization file (~/.emacs or ~/_emacs):
;;
;;      (require 'eyedropper) ; Load this library.
;;
;;    You will also need my library `hexrgb.el'; it is loaded
;;    automatically by `eyedropper.el'.  Get it here:
;;    https://www.emacswiki.org/emacs/download/hexrgb.el.
;;
;;  Commands defined here:
;;
;;    `background-color', `eyedrop-background-at-mouse',
;;    `eyedrop-background-at-point', `eyedrop-foreground-at-mouse',
;;    `eyedrop-foreground-at-point', `eyedropper-background',
;;    `eyedropper-foreground', `eyedrop-pick-background-at-mouse',
;;    `eyedrop-pick-background-at-point',
;;    `eyedrop-pick-foreground-at-mouse',
;;    `eyedrop-pick-foreground-at-point', `foreground-color',
;;    `pick-background-color', `pick-foreground-color'.
;;
;;  Non-interactive functions defined here:
;;
;;    `eyedrop-color-message', `eyedrop-face-at-point', `keywordp'.
;;
;;  Internal variables defined here:
;;
;;    `eyedrop-last-picked-color', `eyedrop-picked-background',
;;    `eyedrop-picked-foreground'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2015/05/09 dadams
;;     eyedrop-(background|foreground)-at-point: Reverse params to and in last let clause.
;; 2013/11/15 dadams
;;     eyedrop-(fore|back)ground-at-point: Return nil if unspecified-(fg|bg).
;; 2012/08/12 dadams
;;     eyedrop-(background|foreground)-at-mouse: Ignore a switch-frame event.
;; 2011/01/04 dadams
;;     Added autoload cookies for commands.
;; 2007/10/11 dadams
;;     eyedrop-(back|fore)ground-at-(mouse|point),
;;     eyedrop-pick-(back|fore)ground-at-(mouse|point), pick-(back|fore)ground-color:
;;       Added optional MSG-P arg (instead of interactive-p).
;; 2006/07/28 dadams
;;     eyedrop-face-at-point: Use car, not caar, for (*-color . "...") test.
;; 2006/06/25 dadams
;;     Added: eyedrop-last-picked-color.  Set it whenever set picked fg or bg.
;; 2006/06/24 dadams
;;     Added: keywordp (for Emacs 20), eyedrop-face-at-point.
;;     eyedrop-(back|fore)ground-at-point: Use eyedrop-face-at-point also.
;; 2006/06/23 dadams
;;     Created.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'hexrgb) ;; hexrgb-hex-to-rgb, hexrgb-rgb-to-hsv

;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar eyedrop-picked-background nil
  "Color last picked from a face or frame background.
You can use `eyedrop-pick-background-at-point' or
`eyedrop-pick-background-at-mouse' to pick the color.")

(defvar eyedrop-picked-foreground nil
  "Color last picked from a face or frame foreground.
You can use `eyedrop-pick-foreground-at-point' or
`eyedrop-pick-foreground-at-mouse' to pick the color.")

(defvar eyedrop-last-picked-color nil
  "Color last picked from a face or frame foreground or background.")

;; This is built-in in Emacs 21; not defined before Emacs 21.
(unless (fboundp 'keywordp)
  (defun keywordp (object)
    "Return t if OBJECT is a keyword.
This means that it is a symbol with a print name beginning with `:'
interned in the initial obarray."
    (and (symbolp object) (string-match "^:" (symbol-name object)) t)))

(defun eyedrop-color-message (color)
  "Display information about COLOR as a message."
  (let* ((rgb (hexrgb-hex-to-rgb color))
         (hsv (apply #'hexrgb-rgb-to-hsv rgb)))
    (message (format "Color: %s, RGB: %s, HSV: %s" color rgb hsv)))
  color)                                ; Return it.

;;;###autoload
(defun eyedrop-background-at-mouse (event &optional msg-p)
  "Return the background color under the mouse pointer.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  ;; Ignore `switch-frame' events.
  (when (and (consp event)  (eq (event-basic-type (car event)) 'switch-frame))
    (setq event  (read-event)))
  (set-buffer (window-buffer (posn-window (event-end event))))
  (mouse-set-point event)
  (let ((bg (eyedrop-background-at-point)))
    (when msg-p (if bg (eyedrop-color-message bg) (message "No background color here")))
    bg))

;;;###autoload
(defun eyedrop-foreground-at-mouse (event &optional msg-p)
  "Return the foreground color under the mouse pointer.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  ;; Ignore `switch-frame' events.
  (when (and (consp event)  (eq (event-basic-type (car event)) 'switch-frame))
    (setq event  (read-event)))
  (set-buffer (window-buffer (posn-window (event-end event))))
  (mouse-set-point event)
  (let ((fg (eyedrop-foreground-at-point)))
    (when msg-p (if fg (eyedrop-color-message fg) (message "No foreground color here")))
    fg))

;; RMS added this function to Emacs (23) as `face-at-point'.
(defun eyedrop-face-at-point ()
  "Return the face under the text cursor.
If there is more than one face, return the first one.
Return nil if there is no face at point."
  (let* ((faceprop (or (get-char-property (point) 'read-face-name)
                       (get-char-property (point) 'face)
                       'default))
         (face (cond ((symbolp faceprop) faceprop)
                     ;; List of faces (don't treat an attribute spec).
                     ;; Just use the first face.
                     ((and (consp faceprop) (not (keywordp (car faceprop)))
                           (not (memq (car faceprop) '(foreground-color background-color))))
                      (car faceprop))
                     (t nil))))         ; Invalid face value.
    (if (facep face) face nil)))

;; RMS added this function to Emacs (23) as `background-color-at-point'.
;;;###autoload
(defalias 'background-color 'eyedrop-background-at-point)
;;;###autoload
(defun eyedrop-background-at-point (&optional msg-p)
  "Return the background color under the text cursor.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  ;; `eyedrop-face-at-point' alone is not sufficient.  It only gets named faces.
  ;; Need also pick up any face properties that are not associated with named faces.
  (let* ((face  (or (eyedrop-face-at-point)
                    (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face)))
         (bg    (cond ((and face (symbolp face))
                       (condition-case nil
                           (face-background face nil 'default) ; Emacs 22+.
                         (error (or (face-background face) ; Emacs 20
                                    (cdr (assq 'background-color (frame-parameters)))))))
                      ((consp face)
                       (cond ((memq 'background-color face)
                              (cdr (memq 'background-color face)))
                             ((memq ':background face)
                              (cadr (memq ':background face)))))
                      (t nil)))         ; Invalid face value.
         (bg    (and (not (member bg '("unspecified-fg" "unspecified-bg")))  bg)))
    (when msg-p
      (if bg (eyedrop-color-message bg) (message "No background color here")))
    bg))

;; RMS added this function to Emacs (23) as `foreground-color-at-point'.
;;;###autoload
(defalias 'foreground-color 'eyedrop-foreground-at-point)
;;;###autoload
(defun eyedrop-foreground-at-point (&optional msg-p)
  "Return the foreground color under the text cursor.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  ;; `eyedrop-face-at-point' alone is not sufficient.  It only gets named faces.
  ;; Need also pick up any face properties that are not associated with named faces.
  (let* ((face  (or (eyedrop-face-at-point)
                    (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face)))
         (fg    (cond ((and face (symbolp face))
                       (condition-case nil
                           (face-foreground face nil 'default) ; Emacs 22+.
                         (error (or (face-foreground face) ; Emacs 20
                                    (cdr (assq 'foreground-color (frame-parameters)))))))
                      ((consp face)
                       (cond ((memq 'foreground-color face)
                              (cdr (memq 'foreground-color face)))
                             ((memq ':foreground face)
                              (cadr (memq ':foreground face)))))
                      (t nil)))         ; Invalid face value.
         (fg    (and (not (member fg '("unspecified-fg" "unspecified-bg")))  fg)))
    (when msg-p
      (if fg (eyedrop-color-message fg) (message "No foreground color here")))
    fg))

;;;###autoload
(defun eyedrop-pick-background-at-mouse (event &optional msg-p)
  "Pick background of face or frame at character under the mouse pointer.
Save the background color in `eyedrop-picked-background' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  (setq eyedrop-picked-background (eyedrop-background-at-mouse event)
        eyedrop-last-picked-color eyedrop-picked-background)
  (unless (stringp eyedrop-picked-background) (error "No background color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-background))
  eyedrop-picked-background)

;;;###autoload
(defun eyedrop-pick-foreground-at-mouse (event &optional msg-p)
  "Pick foreground of face or frame at character under the mouse pointer.
Save the foreground color in `eyedrop-picked-foreground' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  (setq eyedrop-picked-foreground (eyedrop-foreground-at-mouse event)
        eyedrop-last-picked-color eyedrop-picked-foreground)
  (unless (stringp eyedrop-picked-foreground) (error "No foreground color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-foreground))
  eyedrop-picked-foreground)

;;;###autoload
(defalias 'eyedropper-background 'eyedrop-pick-background-at-point)
;;;###autoload
(defalias 'pick-background-color 'eyedrop-pick-background-at-point)
;;;###autoload
(defun eyedrop-pick-background-at-point (&optional msg-p)
  "Pick background of face or frame at character at text cursor (point).
Save the background color in `eyedrop-picked-background' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  (setq eyedrop-picked-background (eyedrop-background-at-point)
        eyedrop-last-picked-color eyedrop-picked-background)
  (unless (stringp eyedrop-picked-background) (error "No background color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-background))
  eyedrop-picked-background)

;;;###autoload
(defalias 'eyedropper-foreground 'eyedrop-pick-foreground-at-point)
;;;###autoload
(defalias 'pick-foreground-color 'eyedrop-pick-foreground-at-point)
;;;###autoload
(defun eyedrop-pick-foreground-at-point (&optional msg-p)
  "Pick foreground of face or frame at character at text cursor (point).
Save the foreground color in `eyedrop-picked-foreground' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  (setq eyedrop-picked-foreground (eyedrop-foreground-at-point)
        eyedrop-last-picked-color eyedrop-picked-foreground)
  (unless (stringp eyedrop-picked-foreground) (error "No foreground color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-foreground))
  eyedrop-picked-foreground)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'eyedropper)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; eyedropper.el ends here
#+end_src

** fringe.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; fringe.el --- fringe setup and control  -*- coding: utf-8 -*-

;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008,
;;   2009 Free Software Foundation, Inc.

;; Author: Simon Josefsson <simon@josefsson.org>
;; Maintainer: FSF
;; Keywords: frames

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This file contains code to initialize the built-in fringe bitmaps
;; as well as helpful functions for customizing the appearance of the
;; fringe.

;; The code is influenced by scroll-bar.el and avoid.el.  The author
;; gratefully acknowledge comments and suggestions made by Miles
;; Bader, Eli Zaretski, Richard Stallman, Pavel JanÃ­k and others which
;; improved this package.

;;; Code:

(defgroup fringe nil
  "Window fringes."
  :version "22.1"
  :group 'frames)

;; Define the built-in fringe bitmaps and setup default mappings

(when (boundp 'fringe-bitmaps)
  (let ((bitmaps '(question-mark
		   left-arrow right-arrow up-arrow down-arrow
		   left-curly-arrow right-curly-arrow
		   left-triangle right-triangle
		   top-left-angle top-right-angle
		   bottom-left-angle bottom-right-angle
		   left-bracket right-bracket
		   filled-rectangle hollow-rectangle
		   filled-square hollow-square
		   vertical-bar horizontal-bar
		   empty-line))
	(bn 1))
    (while bitmaps
      (push (car bitmaps) fringe-bitmaps)
      (put (car bitmaps) 'fringe bn)
      (setq bitmaps (cdr bitmaps)
	    bn (1+ bn))))

  (setq-default fringe-indicator-alist
		'((truncation . (left-arrow right-arrow))
		  (continuation . (left-curly-arrow right-curly-arrow))
		  (overlay-arrow . right-triangle)
		  (up . up-arrow)
		  (down . down-arrow)
		  (top . (top-left-angle top-right-angle))
		  (bottom . (bottom-left-angle bottom-right-angle
			     top-right-angle top-left-angle))
		  (top-bottom . (left-bracket right-bracket
				 top-right-angle top-left-angle))
		  (empty-line . empty-line)
		  (unknown . question-mark)))

  (setq-default fringe-cursor-alist
		'((box . filled-rectangle)
		  (hollow . hollow-rectangle)
		  (bar . vertical-bar)
		  (hbar . horizontal-bar)
		  (hollow-small . hollow-square))))


(defmacro fringe-bitmap-p (symbol)
  "Return non-nil if SYMBOL is a fringe bitmap."
  `(get ,symbol 'fringe))


;; Control presence of fringes

(defvar fringe-mode)

(defvar fringe-mode-explicit nil
  "Non-nil means `set-fringe-mode' should really do something.
This is nil while loading `fringe.el', and t afterward.")

(defun set-fringe-mode-1 (ignore value)
  "Call `set-fringe-mode' with VALUE.
See `fringe-mode' for valid values and their effect.
This is usually invoked when setting `fringe-mode' via customize."
  (set-fringe-mode value))

(defun set-fringe-mode (value)
  "Set `fringe-mode' to VALUE and put the new value into effect.
See `fringe-mode' for possible values and their effect."
  (setq fringe-mode value)

  (when fringe-mode-explicit
    (modify-all-frames-parameters
     (list (cons 'left-fringe (if (consp fringe-mode)
				  (car fringe-mode)
				fringe-mode))
	   (cons 'right-fringe (if (consp fringe-mode)
				   (cdr fringe-mode)
				 fringe-mode))))))

;; For initialization of fringe-mode, take account of changes
;; made explicitly to default-frame-alist.
(defun fringe-mode-initialize (symbol value)
  (let* ((left-pair (assq 'left-fringe default-frame-alist))
	 (right-pair (assq 'right-fringe default-frame-alist))
	 (left (cdr left-pair))
	 (right (cdr right-pair)))
    (if (or left-pair right-pair)
	;; If there's something in default-frame-alist for fringes,
	;; don't change it, but reflect that into the value of fringe-mode.
	(progn
	  (setq fringe-mode (cons left right))
	  (if (equal fringe-mode '(nil . nil))
	      (setq fringe-mode nil))
	  (if (equal fringe-mode '(0 . 0))
	      (setq fringe-mode 0)))
      ;; Otherwise impose the user-specified value of fringe-mode.
      (custom-initialize-reset symbol value))))

(defcustom fringe-mode nil
  "Specify appearance of fringes on all frames.
This variable can be nil (the default) meaning the fringes should have
the default width (8 pixels), it can be an integer value specifying
the width of both left and right fringe (where 0 means no fringe), or
a cons cell where car indicates width of left fringe and cdr indicates
width of right fringe (where again 0 can be used to indicate no
fringe).
To set this variable in a Lisp program, use `set-fringe-mode' to make
it take real effect.
Setting the variable with a customization buffer also takes effect.
If you only want to modify the appearance of the fringe in one frame,
you can use the interactive function `set-fringe-style'."
  :type '(choice (const :tag "Default width" nil)
		 (const :tag "No fringes" 0)
		 (const :tag "Only right" (0 . nil))
		 (const :tag "Only left" (nil . 0))
		 (const :tag "Half width" (5 . 5))
		 (const :tag "Minimal" (1 . 1))
		 (integer :tag "Specific width")
		 (cons :tag "Different left/right sizes"
		       (integer :tag "Left width")
		       (integer :tag "Right width")))
  :group 'fringe
  :require 'fringe
  :initialize 'fringe-mode-initialize
  :set 'set-fringe-mode-1)

;; We just set fringe-mode, but that was the default.
;; If it is set again, that is for real.
(setq fringe-mode-explicit t)

(defun fringe-query-style (&optional all-frames)
  "Query user for fringe style.
Returns values suitable for left-fringe and right-fringe frame parameters.
If ALL-FRAMES, the negation of the fringe values in
`default-frame-alist' is used when user enters the empty string.
Otherwise the negation of the fringe value in the currently selected
frame parameter is used."
  (let ((mode (intern (completing-read
		       (concat
			"Select fringe mode for "
			(if all-frames "all frames" "selected frame")
			" (type ? for list): ")
		       '(("none") ("default") ("left-only")
			 ("right-only") ("half") ("minimal"))
		       nil t))))
    (cond ((eq mode 'none) 0)
	  ((eq mode 'default) nil)
	  ((eq mode 'left-only) '(nil . 0))
	  ((eq mode 'right-only) '(0 . nil))
	  ((eq mode 'half) '(5 . 5))
	  ((eq mode 'minimal) '(1 . 1))
	  ((eq mode (intern ""))
	   (if (eq 0 (cdr (assq 'left-fringe
				(if all-frames
				    default-frame-alist
				  (frame-parameters (selected-frame))))))
	       nil
	     0)))))

(defun fringe-mode (&optional mode)
  "Set the default appearance of fringes on all frames.

When called interactively, query the user for MODE.  Valid values
for MODE include `none', `default', `left-only', `right-only',
`minimal' and `half'.

When used in a Lisp program, MODE can be a cons cell where the
integer in car specifies the left fringe width and the integer in
cdr specifies the right fringe width.  MODE can also be a single
integer that specifies both the left and the right fringe width.
If a fringe width specification is nil, that means to use the
default width (8 pixels).  This command may round up the left and
right width specifications to ensure that their sum is a multiple
of the character width of a frame.  It never rounds up a fringe
width of 0.

Fringe widths set by `set-window-fringes' override the default
fringe widths set by this command.  This command applies to all
frames that exist and frames to be created in the future.  If you
want to set the default appearance of fringes on the selected
frame only, see the command `set-fringe-style'."
  (interactive (list (fringe-query-style 'all-frames)))
  (set-fringe-mode mode))

(defun set-fringe-style (&optional mode)
  "Set the default appearance of fringes on the selected frame.

When called interactively, query the user for MODE.  Valid values
for MODE include `none', `default', `left-only', `right-only',
`minimal' and `half'.

When used in a Lisp program, MODE can be a cons cell where the
integer in car specifies the left fringe width and the integer in
cdr specifies the right fringe width.  MODE can also be a single
integer that specifies both the left and the right fringe width.
If a fringe width specification is nil, that means to use the
default width (8 pixels).  This command may round up the left and
right width specifications to ensure that their sum is a multiple
of the character width of a frame.  It never rounds up a fringe
width of 0.

Fringe widths set by `set-window-fringes' override the default
fringe widths set by this command.  If you want to set the
default appearance of fringes on all frames, see the command
`fringe-mode'."
  (interactive (list (fringe-query-style)))
  (modify-frame-parameters
   (selected-frame)
   (list (cons 'left-fringe (if (consp mode) (car mode) mode))
	 (cons 'right-fringe (if (consp mode) (cdr mode) mode)))))

(defsubst fringe-columns (side &optional real)
  "Return the width, measured in columns, of the fringe area on SIDE.
If optional argument REAL is non-nil, return a real floating point
number instead of a rounded integer value.
SIDE must be the symbol `left' or `right'."
  (funcall (if real '/ 'ceiling)
	   (or (funcall (if (eq side 'left) 'car 'cadr)
			(window-fringes))
	       0)
           (float (frame-char-width))))

(provide 'fringe)

;; arch-tag: 6611ef60-0869-47ed-8b93-587ee7d3ff5d
;;; fringe.el ends here
#+end_src

** help+20.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; help+20.el --- Extensions to `help.el' for Emacs 20.
;;
;; Filename: help+20.el
;; Description: Extensions to `help.el' for Emacs 20.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2018, Drew Adams, all rights reserved.
;; Created: Tue Mar 16 14:18:11 1999
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 13:12:09 2018 (-0800)
;;           By: dradams
;;     Update #: 2219
;; URL: https://www.emacswiki.org/emacs/download/help%2b20.el
;; Doc URL: https://emacswiki.org/emacs/HelpPlus
;; Keywords: help
;; Compatibility: GNU Emacs 20.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `fit-frame', `frame-fns', `info', `info+20',
;;   `misc-fns', `naked', `strings', `thingatpt', `thingatpt+',
;;   `wid-edit', `wid-edit+', `widget'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `help.el' for Emacs 20.
;;
;;  Commands defined here:
;;
;;    `describe-command', `describe-file', `describe-keymap',
;;    `describe-option', `describe-option-of-type',
;;    `help-on-click/key', `mouse-help-on-click',
;;    `mouse-help-on-mode-line-click', `pop-to-help-toggle',
;;    `view-emacs-lisp-news', `save-*Help*-buffer'.
;;
;;  Non-interactive functions defined here:
;;
;;    `help-custom-type', `help-on-click/key-lookup',
;;    `help-remove-duplicates', `help-value-satisfies-type-p',
;;    `help-var-inherits-type-p', `help-var-is-of-type-p',
;;    `help-var-matches-type-p', `help-var-val-satisfies-type-p',
;;    `remove-help-window'.
;;
;;  Internal variables defined here:
;;
;;    `help-origin-buffer'.
;;
;;
;;  ***** NOTE: The following functions defined in `help.el' have
;;              been REDEFINED HERE:
;;
;;  `describe-function', `describe-function-1', `describe-key',
;;  `describe-mode', `describe-project', `describe-variable',
;;  `help-mode', `help-with-tutorial', `locate-library',
;;  `view-emacs-FAQ', `view-emacs-news', `where-is'.
;;
;;
;;  ***** NOTE: The doc string for `help-for-help' has been
;;              REDEFINED HERE
;;              (see `make-help-screen help-for-help')
;;
;;  The following bindings are made here:
;;
;;    `q'          `View-quit' (in `help-mode')
;;    `C-h c'      `describe-command' (replaces `describe-key-briefly')
;;    `C-h o'      `describe-option'
;;    `C-h u'      `manual-entry'
;;    `C-h C-a'    `apropos'
;;    `C-h C-c'    `describe-key-briefly' (replaces `describe-copying')
;;    `C-h C-l'    `locate-library'
;;    `C-h C-n'    `view-emacs-lisp-news'
;;    `C-h C-o'    `describe-option-of-type'
;;    `C-h C-s'    `save-*Help*-buffer'
;;    `C-h RET'    `help-on-click/key'
;;    `C-h M-a'    `apropos-documentation'
;;    `C-h M-c'    `describe-copying' (replaces `C-h C-c')
;;    `C-h M-f'    `describe-file'
;;    `C-h M-k'    `describe-keymap'
;;    `C-h M-o'    `pop-to-help-toggle'
;;    `C-h M-C-a'  `tags-apropos'
;;    [mouse-1]    `mouse-help-on-click' (non-mode-line)
;;    [mouse-1]    `mouse-help-on-mode-line-click' (mode-line)
;;
;;  Suggested additional binding:
;;
;;   (global-set-key [f1] 'help-on-click/key)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2017/01/15 dadams
;;     Added redefinition of describe-function-1.  Handle Emacs bug from its own advice.
;; 2014/05/04 dadams
;;     Soft-require info+20.el (new) instead of info+.el.
;; 2012/09/24 dadams
;;     describe-file: Added optional arg NO-ERROR-P.
;; 2012/08/21 dadams
;;     Call tap-put-thing-at-point-props after load thingatpt+.el.
;; 2012/08/18 dadams
;;     Invoke tap-define-aliases-wo-prefix if thingatpt+.el is loaded.
;;     help-on-click/key: Use tap-symbol-at-point, not symbol-at-point, if defined.
;; 2012/01/11 dadams
;;     describe-variable: Remove * from beginning of doc string.
;; 2011/12/19 dadams
;;     help-with-tutorial, describe-variable: Use line-end-position, not end-of-line + point.
;;     describe-variable: if -> when.
;; 2011/10/07 dadams
;;     Added soft require of naked.el.
;;     describe-key, where-is, help-on-click/key-lookup: Use naked-key-description if available.
;; 2011/04/25 dadams
;;     describe-file: Incorporate autofile bookmark description.  Added optional arg.
;; 2011/03/31 dadams
;;     help-var-(matches|inherits)-type-p: Wrap string-match with save-match-data.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non-interactive function and define-key.
;; 2009/08/30 dadams
;;     describe-keymap: Don't print nil if the map has no doc.
;; 2008/08/19 dadams
;;     describe-keymap: Use insert instead of princ for map part.  Thx to Chong Yidong.
;; 2008/05/20 dadams
;;     describe-function: Different prompt if prefix arg.
;; 2008/03/02 dadams
;;     Moved describe-file here from misc-cmds.el.  Bound to C-h M-f.
;; 2008/01/17 dadams
;;     Removed soft require of icicles.el
;; 2007/12/25 dadams
;;     help-var-inherits-type-p:
;;       Recheck var-type match after set var-type to its car.
;;       Handle string (regexp) TYPES elements.
;;     help-value-satisfies-type-p: Skip type check for string type (regexp).
;;     help-var-is-of-type-p: Doc string.  Use help-var-matches-type-p.
;;     Added: help-var-matches-type-p.
;; 2007/12/24 dadams
;;     help-var-inherits-type-p: Recheck type match after set var-type to its car.
;;     Added: help-custom-type.
;; 2007/12/23 dadams
;;     help-var-is-of-type-p:
;;       Added MODE arg.  Use help-var-inherits-type-p, help-var-val-satisfies-type-p.
;;       Redefined as MODE choice, not just a simple or.  Treat more cases.
;;     Added: help-var-inherits-type-p, help-var-val-satisfies-type-p,
;;            help-value-satisfies-type-p.
;;     describe-option-of-type: Prefix arg means use mode inherit-or-value.
;; 2007/12/22 dadams
;;     help-var-is-of-type-p:
;;       Check supertypes also.  Use both :validate and :match.
;;       Wrap type check in condition-case. Use widget-put instead of plist-put.
;;     Added soft require of wid-edit+.el.
;; 2007/12/21 dadams
;;     help-var-is-of-type-p: Use :validate, not :match, for the test.
;; 2007/12/20 dadams
;;     Swapped C-o and M-o bindings.
;; 2007/12/15 dadams
;;     Bound C-h c to describe-command and C-h C-c to describe-key-briefly.
;; 2007/12/14 dadams
;;     Renamed library from help+.el to help+20.el.  New help+.el is for Emacs 22+.
;;     Removed commented Emacs 19 stuff.
;;     view-emacs-lisp-news, describe-(key|function|variable):
;;       Removed emacs-major-version test.
;;     Added: Redefinition of help-mode.
;;     Bound q in help-mode to View-quit.
;;     Don't require cl.el if before Emacs 20.
;; 2007/12/13 dadams
;;     help-on-click/key: Removed extra arg in call to message.
;;     help-for-help: Reordered help string.
;; 2007/12/09 dadams
;;     (make-help-screen help-for-help...): Rewrote help text.
;; 2007/12/07 dadams
;;     describe-variable: if OPTIONP, then allow custom-variable-p as well as user-variable-p.
;;     describe-option-of-type: Use "nil" as default value.
;; 2007/12/06 dadams
;;     describe-option-of-type:
;;       If nil type, all defcustom vars are candidates.  Use custom-variable-p, if available.
;;       Specific error if no such custom type.
;;     describe-option: Use both custom-variable-p and user-variable-p.
;; 2007/12/04 dadams
;;     Added: describe-option-of-type, help-remove-duplicates, help-var-is-of-type-p.
;;     Bound o to describe-option (no longer edit-options), M-o to describe-option-of-type,
;;       C-c to describe-command, M-c to describe-copying.
;; 2007/11/28 dadams
;;     Renamed describe-bindings-in-map to describe-keymap.  Added keymap's doc string.
;; 2007/11/27 dadams
;;     locate-library: Use icicle-read-string-completing, if available.
;;     Soft require Icicles.
;; 2007/11/22 dadams
;;     Added: describe-bindings-in-map.  Bound to C-h M-k.
;; 2007/10/17 dadams
;;     describe-(function|variable): Prefix arg means describe only commands or user options.
;;     Added: describe-(command|option).
;; 2007/09/04 dadams
;;     remove-windows-on -> delete-windows-on.  Removed require of frame-cmds.el.
;; 2006/12/08 dadams
;;     describe-variable: Fixed interactive case when symbol-nearest-point is not defined.
;; 2006/07/11 dadams
;;     Added: help-origin-buffer, pop-to-help-toggle.  Bound latter to C-h C-o globally
;; 2005/10/31 dadams
;;     Use nil as init-value arg in calls to completing-read, everywhere.
;; 2001/01/10 dadams
;;     Protected remove-windows-on via fboundp.
;; 1999/08/12 dadams
;;     Added doc strings for help-on-click/key(-lookup) and updated header.
;; 1999/04/09 dadams
;;     help-on-click/key: Treat mouse click on symbol via apropos.
;; 1999/04/08 dadams
;;     help-on-click/key: 1. Treat mouse menus.
;;                        2. Corrected: flush extra mode-line mouse events.
;; 1999/04/08 dadams
;;     help-on-click/key: Bound temp-buffer-show-function so use other win.
;; 1999/04/08 dadams
;;     1. Added binding: help-on-click/key.
;;     2. Added: make-help-screen help-for-help.
;;     3. help-on-click/key-lookup: show-*Help*-buffer.
;;     4. help-on-click/key: Prompt.  Corrected: event->key, show-*Help*-buffer.
;; 1999/04/07 dadams
;;     1. Added: (replacement) describe-key.
;;     2. Added: help-on-click/key-lookup, help-on-click/key.
;; 1999/04/06 dadams
;;     Added binding for save-*Help*-buffer.
;; 1999/04/06 dadams
;;     1. Added some key bindings: o, u, C-l, C-a, M-a, C-M-a.
;;     2. Added: save-*Help*-buffer.
;; 1999/03/31 dadams
;;     Protected symbol-nearest-point with fboundp.
;; 1999/03/17 dadams
;;     1. Added: remove-help-window, help-with-tutorial, describe-project,
;;        view-emacs-FAQ, view-emacs-news, describe-function, describe-variable,
;;        where-is, locate-library, view-emacs-lisp-news.
;;     2. help-iso-prefix: Treat unbound iso-transl-char-map error.  Removed
;;        highlighting.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'info nil t) ;; (no error if not found):
                      ;; Info-exit, Info-goto-node, Info-goto-emacs-key-command-node
(require 'info+20 nil t) ;; (no error if not found):
                         ;; Info-goto-emacs-key-command-node (returns found-p)
(require 'thingatpt nil t) ;; (no error if not found): symbol-at-point

(when (and (require 'thingatpt+ nil t);; (no error if not found)
           (fboundp 'tap-put-thing-at-point-props)) ; >= 2012-08-21
  (tap-define-aliases-wo-prefix)
  (tap-put-thing-at-point-props))
  ;;  symbol-nearest-point, tap-symbol-at-point

(require 'frame-fns nil t) ;; (no error if not found): 1-window-frames-on
(require 'wid-edit+ nil t) ;; (no error if not found):
                           ;; redefined color widget (for help-var-is-of-type-p)
(require 'naked nil t) ;; (no error if not found): naked-key-description

;; Get macro `make-help-screen' when this is compiled,
;; or run interpreted, but not when the compiled code is loaded.
(eval-when-compile
  (require 'help-macro nil t) ;; (no error if not found) make-help-screen
  (require 'help-macro+ nil t)) ;; (no error if not found): make-help-screen
;; (require 'icicles nil t) ;; (no error if not found): icicle-read-string-completing


;; Quiet the byte-compiler.
(defvar view-no-disable-on-exit)
(defvar view-exit-action)

;;;;;;;;;;;;;;;;;;;;

(defvar help-origin-buffer nil "Buffer that we left, to go to *Help*.")

(define-key help-map "c" 'describe-command)
(define-key help-map "o" 'describe-option)
(define-key help-map "u" 'manual-entry) ; in `man.el'
(define-key help-map "\C-a" 'apropos)
(define-key help-map "\C-c" 'describe-key-briefly)
(define-key help-map "\C-l" 'locate-library)
(define-key help-map [?\C-m] 'help-on-click/key) ; RET
(define-key help-map [?\C-n] 'view-emacs-lisp-news)
(define-key help-map "\C-o" 'describe-option-of-type)
(define-key help-map "\C-s" 'save-*Help*-buffer)
(define-key help-map "\M-a" 'apropos-documentation)
(define-key help-map "\M-c" 'describe-copying)
(define-key help-map "\M-f" 'describe-file)
(define-key help-map "\M-k" 'describe-keymap)
(define-key help-map "\M-o" 'pop-to-help-toggle)
(define-key help-map "\M-\C-a" 'tags-apropos)
(define-key help-map [down-mouse-1] 'mouse-help-on-click)
(define-key help-map [mode-line down-mouse-1] 'mouse-help-on-mode-line-click)

;; `help-mode' too needs a quit key.
(define-key help-mode-map "q" 'View-quit)


(defsubst remove-help-window ()
  "If called from `help-for-help', remove display of help window."
  (when (eq 'help-for-help this-command) (delete-windows-on "*Help*")))


;; REPLACES ORIGINAL in `help.el':
;; Deletes *Help* frame when done, if `one-window-p'.
;;
;;;###autoload
(defun help-mode ()
  "Major mode for viewing help text and navigating references in it.
Entry to this mode runs the normal hook `help-mode-hook'.
Commands:
\\{help-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map help-mode-map)
  (setq mode-name   "Help"
        major-mode  'help-mode)
  (make-local-variable 'font-lock-defaults)
  (setq font-lock-defaults  nil)        ; font-lock would defeat xref
  (view-mode)
  (make-local-variable 'view-no-disable-on-exit)
  (setq view-no-disable-on-exit  t
        view-exit-action         (lambda (buffer)
                                   (or (window-minibuffer-p (selected-window))
                                       (when (eq (window-buffer) (get-buffer "*Help*"))
                                         (if (one-window-p t)
                                             (delete-frame)
                                           (delete-window))))))
  ;; `help-make-xrefs' would be run here if not invoked from
  ;; `help-mode-maybe'.
  (run-hooks 'help-mode-hook))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages added.
;;;###autoload
(defun help-with-tutorial (&optional arg)
  "Select the Emacs learn-by-doing tutorial.
If there is a tutorial version written in the language
of the selected language environment, that version is used.
If there's no tutorial in that language, `TUTORIAL' is selected.
With prefix ARG, you are asked to choose which language."
  (interactive "P")
  (message "Looking for Emacs Tutorial file...")
  (let ((lang  (if arg
                   (read-language-name 'tutorial "Language: " "English")
                 (if (get-language-info current-language-environment 'tutorial)
                     current-language-environment
                   "English")))
        file filename)
    (setq filename  (get-language-info lang 'tutorial)
          file      (expand-file-name (concat "~/" filename)))
    (delete-other-windows)
    (if (get-file-buffer file)
        (switch-to-buffer-other-window (get-file-buffer file))
      (switch-to-buffer-other-window (create-file-buffer file))
      (setq buffer-file-name            file
            default-directory           (expand-file-name "~/")
            buffer-auto-save-file-name  nil)
      (insert-file-contents (expand-file-name filename data-directory))
      (goto-char (point-min))
      (search-forward "\n<<")
      (beginning-of-line)
      (delete-region (point) (line-end-position))
      (let ((n  (- (window-height (selected-window))
                   (count-lines (point-min) (point))
                   6)))
        (if (< n 12)
            (newline n)
          ;; Some people get confused by the large gap.
          (newline (/ n 2))
          (insert "[Middle of page left blank for didactic purposes.  "
                  "Text continues below]")
          (newline (- n (/ n 2)))))
      (goto-char (point-min))
      (set-buffer-modified-p nil)))
  (remove-help-window)
  (message "Looking for Emacs Tutorial file...done"))


;; REPLACES ORIGINAL in `help.el':
;; Return nil if KEY is undefined; else return t.
;;
;;;###autoload
(defun describe-key (key)
  "Describe the command that a keyboard/menu/mouse sequence invokes.
Argument KEY is a string.
Return nil if KEY is undefined; else return t."
  (interactive "kDescribe command bound to keyboard/menu/mouse sequence: ")
  (save-excursion
    (let ((modifiers  (event-modifiers (aref key 0)))
          window position)
      ;; For a mouse button event, go to the button it applies to
      ;; to get the right key bindings.  And go to the right place
      ;; in case the keymap depends on where you clicked.
      (if (or (memq 'click modifiers) (memq 'down modifiers)
              (memq 'drag modifiers))
          (setq window    (posn-window (event-start (aref key 0)))
                position  (posn-point (event-start (aref key 0)))))
      (if (windowp window)
          (progn
            (set-buffer (window-buffer window))
            (goto-char position)))
      (let ((defn  (key-binding key)))
        (cond ((or (null defn) (integerp defn))
               (message "`%s' is undefined." (if (fboundp 'naked-key-description)
                                                 (naked-key-description key)
                                               (key-description key)))
               nil)                     ; Return nil: undefined.
              (t
               (with-output-to-temp-buffer "*Help*"
                 (princ (if (fboundp 'naked-key-description)
                            (naked-key-description key)
                          (key-description key)))
                 (if (windowp window)
                     (princ " at that spot"))
                 (princ " runs the command ")
                 (prin1 defn)
                 (princ "\n   which is ")
                 (describe-function-1 defn nil (interactive-p))
                 (print-help-return-message))
               t))))))                  ; Return t: defined.


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages.
;;
;;;###autoload
(defun describe-project ()
  "Display information on the GNU project."
  (interactive)
  (message "Looking for file describing GNU project...")
  (find-file-read-only-other-window (expand-file-name "GNU" data-directory))
  (remove-help-window)
  (message "Looking for file describing GNU project...done"))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages added.
;; 4. Turns off `auto-save-mode'.
;;
;;;###autoload
(defun view-emacs-news (&optional arg)
  "Display information on recent changes to Emacs.
With numeric prefix ARG, display correspondingly older changes."
  (interactive "P")
  (message "Looking for Emacs Changes file...")
  (let ((arg  (if arg (prefix-numeric-value arg) 0)))
    (find-file-read-only-other-window
     (expand-file-name (concat (make-string arg ?O) "NEWS")
                       data-directory)))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs Changes file...done"))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Turns off `auto-save-mode'.
;;
;;;###autoload
(defun view-emacs-FAQ ()
  "Display Frequently Asked Questions about Emacs (with answers)."
  (interactive)
  (message "Looking for Emacs FAQ file...")
  (find-file-read-only-other-window (expand-file-name "FAQ" data-directory))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs FAQ file...done"))


;; REPLACES ORIGINAL in `help.el':
;; Updated key bindings.
;;
(make-help-screen help-for-help
  "RET [abcCfFhiIklLmnopqstuvw] C-[\acdfiklnopsw] M-[acko] C-M-a (? for more help):"
  "This is the Emacs `help-command', accessible via `%THIS-KEY%'.
Type a Help option (below) now, for help on a particular topic.
Use \\<help-map>`\\[scroll-up]' or `\\[scroll-down]' to scroll this text.  \
Type `\\[help-quit]' to exit Help.
\(A \"command\" is any function that you can execute via `M-x'.)

LEARNING EMACS
--------------
\\[help-with-tutorial]:   Starts a tutorial for learning Emacs.
\\[view-emacs-FAQ]:   Explains frequently asked Emacs questions.

COMMONLY USED
-------------
\\[help-on-click/key]: Help about a key sequence or something you click with the mouse.
\\[apropos-command]:   Shows commands that match a regular expression (regexp).
\\[describe-bindings]:   Shows current key bindings: keyboard, menu bar, and mouse.
\\[describe-command]:   Shows the doc for an Emacs command.
\\[describe-function]:   Shows the doc for an Emacs function.
\\[info]:   Enters `Info', to browse manuals, including Emacs and Emacs Lisp.
\\[describe-key]:   Describes the command bound to keyboard/menu/mouse sequence.
\\[describe-mode]:   Describes the current major and minor modes.
\\[describe-option]:   Shows an Emacs user option's value and documentation.
\\[describe-variable]:   Shows an Emacs variable's value and documentation.
\\[Info-goto-emacs-command-node]: Opens the Emacs manual for an Emacs command.
\\[Info-goto-emacs-key-command-node]: Opens the Emacs manual for a keyboard/menu/mouse \
sequence.

MORE ADVANCED HELP
------------------
\\[view-lossage]:   Shows what you just typed (last 100 keystrokes & mouse actions).
\\[view-emacs-news]:   Describes what's new in this Emacs release.
\\[finder-by-keyword]:   Finds Emacs-Lisp libraries that match a topic.
\\[describe-syntax]:   Describes the current syntax table.
\\[manual-entry]:   Finds a topic in the Unix manual.
\\[where-is]:   Identifies a keyboard/menu/mouse sequence that invokes a command.
\\[apropos]: Shows Emacs functions and variables that match a regexp.
\\[describe-key-briefly]: Identifies the command bound to a keyboard/menu/mouse sequence.
\\[describe-distribution]: Shows Emacs ordering information.
\\[locate-library]: Shows the path name to an Emacs library.
\\[view-emacs-lisp-news]: Describes latest Emacs Lisp changes.
\\[describe-project]: Shows information about the GNU project.
\\[save-*Help*-buffer]: Renames buffer *Help* as buffer *Help*<N>.
\\[describe-no-warranty]: Shows information about the absence of a warranty.
\\[apropos-documentation]: Shows Emacs functions and variables whose doc matches a regexp.
\\[describe-copying]: Shows the GNU Emacs General Public License.
\\[pop-to-help-toggle]: Pops to Help buffer or back to the buffer that sent you to Help.
\\[tags-apropos]: Shows the tags matched by a given string.

INTERNATIONAL
-------------
\\[describe-coding-system]:   Describes a coding system.
h    Displays the HELLO file, which illustrates scripts and languages.
\\[describe-input-method]:   Describes an input method.
\\[describe-language-environment]:   Describes a language environment.
\\[info-lookup-symbol]: Finds a symbol in the manual for the current buffer's language.
"
  help-map)


(or (fboundp 'old-describe-mode)
    (fset 'old-describe-mode (symbol-function 'describe-mode)))


;; REPLACES ORIGINAL in `help.el':
;; 1. Provides message telling how to change pages in *Help* buffer.
;; 2. Doc string also explains this.
;;    Really, the text at the beginning of *Help* should explain this - TO BE DONE.
;;
;;;###autoload
(defun describe-mode ()
  "Display documentation of current major mode and minor modes.
Each mode (minor or major) is displayed on a different \"page\" in the
*Help* buffer (the pages are separated by `^L' characters).
You can change pages with `\\[forward-page]' and `\\[backward-page]'.

Note: For a minor mode to be described correctly here, the mode's
indicator variable (listed in `minor-mode-alist') must also be a
function whose documentation describes the minor mode."
  (interactive)
  (let ((font-lock-verbose  nil))       ; This should inhibit msgs, but doesn't!
    (old-describe-mode)
    (message (substitute-command-keys
              "You can use `\\[forward-page]' and `\\[backward-page]' \
in *Help* buffer to change pages."))))


;; REPLACES ORIGINAL in `help.el':
;; Preferred candidate is `symbol-nearest-point'.
;; With a prefix argument, candidates are commands only.
;;
;;;###autoload
(defun describe-function (function &optional commandp)
  "Display the full documentation of FUNCTION (a symbol).
FUNCTION names an Emacs Lisp function, possibly a user command.
With a prefix argument, candidates are commands (interactive) only.
Default candidate is: preferably the `symbol-nearest-point', or else
the innermost function call surrounding point
\(`function-called-at-point').
Return the description that was displayed, as a string."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read
                    (if current-prefix-arg "Describe command: " "Describe function: ")
                    obarray (if current-prefix-arg 'commandp 'fboundp) t nil nil
                    (and fn (symbol-name fn)) t))
           current-prefix-arg)))
  (unless (or (not commandp) (commandp function))
    (error "Not a defined Emacs command (interactive function): `%s'" function))
  (unless (fboundp function)
    (error "Not a defined Emacs function: `%s'" function))
  (with-output-to-temp-buffer "*Help*"
    (prin1 function)
    ;; Use " is " instead of a colon so that
    ;; it is easier to get out the function name using forward-sexp.
    (princ " is ")
    (describe-function-1 function nil (interactive-p))
    (print-help-return-message)
    (save-excursion
      (set-buffer standard-output)
      ;; Return the text we displayed.
      (buffer-string))))


;; REPLACES ORIGINAL in `help.el':
;;
;; Ignore symbols that produce errors.  Example: In Emacs 20, `any', which is defalias'd
;; to `icicle-anything', raises this error: "Symbol's function definition is void: any".
;; This is caused by the `after' advice `ad-advised-docstring' that is defined by Emacs
;; itself for function `documentation'.  It is not a problem for Emacs 22+.
;;
;;;###autoload
(defun describe-function-1 (function parens interactive-p)
  (let* ((def (if (symbolp function)
          (symbol-function function)
        function))
     file-name string need-close
     (beg (if (commandp def) "an interactive " "a ")))
    (setq string
      (cond ((or (stringp def)
             (vectorp def))
         "a keyboard macro")
        ((subrp def)
         (concat beg "built-in function"))
        ((byte-code-function-p def)
         (concat beg "compiled Lisp function"))
        ((symbolp def)
         (while (symbolp (symbol-function def))
           (setq def (symbol-function def)))
         (format "an alias for `%s'" def))
        ((eq (car-safe def) 'lambda)
         (concat beg "Lisp function"))
        ((eq (car-safe def) 'macro)
         "a Lisp macro")
        ((eq (car-safe def) 'mocklisp)
         "a mocklisp function")
        ((eq (car-safe def) 'autoload)
         (setq file-name (nth 1 def))
         (format "%s autoloaded %s"
             (if (commandp def) "an interactive" "an")
             (if (eq (nth 4 def) 'keymap) "keymap"
               (if (nth 4 def) "Lisp macro" "Lisp function"))
             ))
        (t "")))
    (when (and parens (not (equal string "")))
      (setq need-close t)
      (princ "("))
    (princ string)
    (with-current-buffer "*Help*"
      (save-excursion
    (save-match-data
      (if (re-search-backward "alias for `\\([^`']+\\)'" nil t)
          (help-xref-button 1 #'describe-function def)))))
    (or file-name
    (setq file-name (symbol-file function)))
    (if file-name
    (progn
      (princ " in `")
      ;; We used to add .el to the file name,
      ;; but that's completely wrong when the user used load-file.
      (princ file-name)
      (princ "'")
      ;; Make a hyperlink to the library.
      (with-current-buffer "*Help*"
        (save-excursion
          (re-search-backward "`\\([^`']+\\)'" nil t)
          (help-xref-button 1 #'(lambda (arg)
                      (let ((location
                         (find-function-noselect arg)))
                    (pop-to-buffer (car location))
                    (goto-char (cdr location))))
                function)))))
    (if need-close (princ ")"))
    (princ ".")
    (terpri)
    ;; Handle symbols aliased to other symbols.
    (setq def (indirect-function def))
    ;; If definition is a macro, find the function inside it.
    (if (eq (car-safe def) 'macro)
    (setq def (cdr def)))
    (let ((arglist (cond ((byte-code-function-p def)
              (car (append def nil)))
             ((eq (car-safe def) 'lambda)
              (nth 1 def))
             (t t))))
      (if (listp arglist)
      (progn
        (princ (cons (if (symbolp function) function "anonymous")
             (mapcar (lambda (arg)
                   (if (memq arg '(&optional &rest))
                       arg
                     (intern (upcase (symbol-name arg)))))
                 arglist)))
        (terpri))))
    (let ((doc (condition-case nil (documentation function) (error nil))))
      (if doc
      (progn (terpri)
         (princ doc)
         (help-setup-xref (list #'describe-function function) interactive-p))
    (princ "not documented")))))

;;;###autoload
(defun describe-command (function)
  "Describe an Emacs command (interactive function).
Same as using a prefix arg with `describe-function'."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe command: " obarray 'commandp
                                    t nil nil (and fn (symbol-name fn)) t)))))
  (describe-function function t))


;; REPLACES ORIGINAL in `help.el':
;;
;; 1. Preferred candidate is `symbol-nearest-point'.
;; 2. Use `substitute-command-keys' on doc string.
;; 3. Remove initial `*' from doc string (indicates it is a user variable).
;; 4. With a prefix argument, candidates are user variables (options) only.
;;
;;;###autoload
(defun describe-variable (variable &optional optionp)
  "Display the full documentation of VARIABLE (a symbol).
VARIABLE names an Emacs Lisp variable, possibly a user option.
With a prefix argument, candidates are user variables (options) only.
Default candidate is the `symbol-nearest-point'.
Return the documentation, as a string."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (and (symbolp (variable-at-point))
                                                 (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe variable: " obarray
                                    (if current-prefix-arg 'user-variable-p 'boundp)
                                    t nil nil (and symb (symbol-name symb)) t))
           current-prefix-arg)))
  (unless (or (not optionp) (or (user-variable-p variable) (custom-variable-p variable)))
    (error "Not a defined Emacs user option: `%s'" variable))
  (unless (boundp variable) (error "Not a defined Emacs variable: `%s'" variable))
  (let (valvoid)
    (with-output-to-temp-buffer "*Help*"
      (prin1 variable)
      (if (not (boundp variable))       ; This will never happen.
          (progn (princ " is void") (terpri) (setq valvoid  t))
        (princ "'s value is ")
        (terpri)
        (pp (symbol-value variable))
        (terpri))
      (when (local-variable-p variable)
        (princ (format "Local in buffer %s; " (buffer-name)))
        (if (not (default-boundp variable))
            (princ "globally void")
          (princ "global value is ")
          (terpri)
          (pp (default-value variable)))
        (terpri))
      (terpri)
      (save-current-buffer
        (set-buffer standard-output)
        (when (> (count-lines (point-min) (point-max)) 10)
          (goto-char (point-min))
          (if valvoid
              (forward-line 1)
            (forward-sexp 1)
            (delete-region (point) (line-end-position))
            (insert "'s value is shown below.\n\n")
            (save-excursion (insert "\n\nValue:")))))
      (princ "Documentation:")
      (terpri)
      (let ((doc  (documentation-property variable 'variable-documentation)))
        (if (or (null doc)  (string= "" doc))
            (princ "Not documented as a variable.")
          (when (and (> (length doc) 1)  (eq ?* (elt doc 0)))
            (setq doc  (substring doc 1))) ; Remove any user-variable prefix `*'.
          (princ (substitute-command-keys doc))))
      (help-setup-xref (list #'describe-variable variable) (interactive-p))
      ;; Make a link to customize if this variable can be customized.
      ;; Note, it is not reliable to test only for a custom-type property
      ;; because those are only present after the var's definition
      ;; has been loaded.
      (when (or (get variable 'custom-type) ; after defcustom
                (get variable 'custom-loads) ; from loaddefs.el
                (get variable 'standard-value)) ; from cus-start.el
        (let ((customize-label  "customize"))
          (terpri)
          (terpri)
          (princ (concat "You can " customize-label " this variable."))
          (with-current-buffer "*Help*"
            (save-excursion  (re-search-backward
                              (concat "\\(" customize-label "\\)") nil t)
                             (help-xref-button 1 #'(lambda (v)
                                                     (customize-variable v)) variable)))))
      ;; Make a hyperlink to the library if appropriate.  (Don't
      ;; change the format of the buffer's initial line in case
      ;; anything expects the current format.)
      (when (string< "20.5" emacs-version)
        (let ((file-name  (symbol-file variable)))
          (when file-name
            (princ "\n\nDefined in `")
            (princ file-name)
            (princ "'.")
            (with-current-buffer "*Help*"
              (save-excursion
                (re-search-backward "`\\([^`']+\\)'" nil t)
                (help-xref-button 1 (lambda (arg)
                                      (let ((location  (find-variable-noselect arg)))
                                        (pop-to-buffer (car location))
                                        (goto-char (cdr location))))
                                  variable))))))

      (print-help-return-message)
      (save-excursion (set-buffer standard-output)
                      (buffer-string))))) ; Return the text we displayed.

;;;###autoload
(defun describe-option (variable)
  "Describe an Emacs user variable (option).
Same as using a prefix arg with `describe-variable'."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (and (symbolp (variable-at-point))
                                                 (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe user option: " obarray
                                    ;; Emacs 20 `user-variable-p' does not include defcustoms.
                                    (lambda (c) (or (custom-variable-p c) (user-variable-p c)))
                                    t nil nil (and symb (symbol-name symb)) t)))))
  (describe-variable variable t))

;;;###autoload
(defun describe-option-of-type (type option)
  "Describe an Emacs user OPTION (variable) of a given `defcustom' TYPE.
A prefix argument determines the type-checking behavior:
 - None:         OPTION is defined with TYPE or a subtype of TYPE.
 - Plain `C-u':  OPTION is defined with TYPE or a subtype of TYPE,
                 or its current value is compatible with TYPE.
 - Negative:     OPTION is defined with TYPE (exact match).
 - Non-negative: OPTION is defined with TYPE (exact match),
                 or its current value is compatible with TYPE.

If TYPE is nil (default value) then *all* `defcustom' variables are
potential candidates.  That is different from using `describe-option',
because `describe-option' includes user-variable candidates not
defined with `defcustom' (with `*'-prefixed doc strings)."
  (interactive
   (let* ((symb      (or (and (fboundp 'symbol-nearest-point) (symbol-nearest-point))
                         (and (symbolp (variable-at-point)) (variable-at-point))))
          (typ       (car (condition-case err
                              (read-from-string
                               (let ((types  ()))
                                 (mapatoms
                                  (lambda (cand)
                                    (when (if (fboundp 'custom-variable-p) ; Not in Emacs 20.
                                              (custom-variable-p cand)
                                            (user-variable-p cand))
                                      (push (list
                                             (format "%s" (format "%S" (get cand 'custom-type))))
                                            types))))
                                 (completing-read "Describe option of type: "
                                                  (help-remove-duplicates types)
                                                  nil nil nil nil "nil")))
                            (end-of-file (error "No such custom type")))))
          (pref-arg  current-prefix-arg))
     (list typ (intern (completing-read
                        "Option: " obarray
                        (lambda (v)
                          (and (if (fboundp 'custom-variable-p) ; Not in vanilla Emacs 20.
                                   (custom-variable-p v)
                                 (user-variable-p v))
                               (or (not typ) ; Allow all vars if requested type = nil.
                                   (help-var-is-of-type-p
                                    v (list typ)
                                    (cond ((not pref-arg) 'inherit)
                                          ((consp pref-arg) 'inherit-or-value)
                                          ((wholenump (prefix-numeric-value pref-arg))
                                           'direct-or-value)
                                          (t 'direct))))))
                        t nil nil (and symb (symbol-name symb)) t)))))
  (describe-variable option t))

(defun help-var-is-of-type-p (variable types &optional mode)
  "Return non-nil if VARIABLE satisfies one of the custom types in TYPES.
TYPES is a list of `defcustom' type sexps or a list of regexp strings.
TYPES are matched, in order, against VARIABLE's type definition or
VARIABLE's current value, until one is satisfied or all are tried.

If TYPES is a list of regexps, then each is regexp-matched against
VARIABLE's custom type.

Otherwise, TYPES is a list of type sexps, each of which is a
definition acceptable for `defcustom' :type or the first symbol of
such a definition (e.g. `choice').  In this case, two kinds of type
comparison are possible:

1. VARIABLE's custom type, or its first symbol, is matched using
  `equal' against each type in TYPES.

2. VARIABLE's current value is checked against each type in TYPES to
   see if it satisfies one of them.  In this case, VARIABLE's own type
   is not used; VARIABLE might not even be typed - it could be a
   variable not defined using `defcustom'.

For any of the comparisons against VARIABLE's type, either that type
can be checked directly or its supertypes (inherited types) can also
be checked.

These different type-checking possibilities depend on the value of
argument MODE, as follows, and they determine the meaning of the
returned value:

`direct':   VARIABLE's type matches a member of list TYPES
`inherit':  VARIABLE's type matches or is a subtype of a TYPES member
`value':    VARIABLE is bound, and its value satisfies a type in TYPES
`inherit-or-value': `inherit' or `value', tested in that order
`direct-or-value':  `direct' or `value', tested in that order
anything else (default): `inherit'

VARIABLE's current value cannot satisfy a regexp type: it is
impossible to know which concrete types a value must match."
  (case mode
    ((nil inherit)     (help-var-inherits-type-p variable types))
    (inherit-or-value  (or (help-var-inherits-type-p variable types)
                           (help-var-val-satisfies-type-p variable types)))
    (value             (help-var-val-satisfies-type-p variable types))
    (direct            (help-var-matches-type-p variable types))
    (direct-or-value   (or (member (get variable 'custom-type) types)
                           (help-var-val-satisfies-type-p variable types)))
    (otherwise         (help-var-inherits-type-p variable types))))

(defun help-var-matches-type-p (variable types)
  "VARIABLE's type matches a member of TYPES."
  (catch 'help-type-matches
    (let ((var-type  (get variable 'custom-type)))
      (dolist (type  types)
        (when (if (stringp type)
                  (save-match-data (string-match type (format "%s" (format "%S" var-type))))
                (equal var-type type))
          (throw 'help-type-matches t))))
    nil))

(defun help-var-inherits-type-p (variable types)
  "VARIABLE's type matches or is a subtype of a member of list TYPES."
  (catch 'help-type-inherits
    (let ((var-type  (get variable 'custom-type)))
      (dolist (type  types)
        (while var-type
          (when (or (and (stringp type)
                         (save-match-data
                           (string-match type (format "%s" (format "%S" var-type)))))
                    (equal type var-type))
            (throw 'help-type-inherits t))
          (when (consp var-type) (setq var-type  (car var-type)))
          (when (or (and (stringp type)
                         (save-match-data
                           (string-match type (format "%s" (format "%S" var-type)))))
                    (equal type var-type))
            (throw 'help-type-inherits t))
          (setq var-type  (car (get var-type 'widget-type))))
        (setq var-type  (get variable 'custom-type))))
    nil))

(defun help-var-val-satisfies-type-p (variable types)
  "VARIABLE is bound, and its value satisfies a type in the list TYPES."
  (and (boundp variable)
       (let ((val  (symbol-value variable)))
         (and (widget-convert (get variable 'custom-type))
              (help-value-satisfies-type-p val types)))))

(defun help-value-satisfies-type-p (value types)
  "Return non-nil if VALUE satisfies a type in the list TYPES."
  (catch 'help-type-value-satisfies
    (dolist (type  types)
      (unless (stringp type)            ; Skip, for regexp type.
        (setq type  (widget-convert type))
        ;; Satisfies if either :match or :validate.
        (when (condition-case nil
                  (progn (when (and (widget-get type :match)
                                    (widget-apply type :match value))
                           (throw 'help-type-value-satisfies t))
                         (when (and (widget-get type :validate)
                                    (progn (widget-put type :value value)
                                           (not (widget-apply type :validate))))
                           (throw 'help-type-value-satisfies t)))
                (error nil))
          (throw 'help-type-value-satisfies t))))
    nil))

(defun help-custom-type (variable)
  "Returns the `defcustom' type of VARIABLE.
Returns nil if VARIABLE is not a user option.

Note: If the library that defines VARIABLE has not yet been loaded,
then `help-custom-type' loads it.  Be sure you want to do that
before you call this function."
  (and (custom-variable-p variable)
       (or (get variable 'custom-type) (progn (custom-load-symbol variable)
                                              (get variable 'custom-type)))))

;; Borrowed from `ps-print.el'
(defun help-remove-duplicates (list)
  "Copy of LIST with duplicate elements removed.  Tested with `equal'."
  (let ((tail  list)
        new)
    (while tail
      (unless (member (car tail) new) (push (car tail) new))
      (pop tail))
    (nreverse new)))

;;;###autoload
(defun describe-file (filename &optional internal-form-p no-error-p)
  "Describe the file named FILENAME.
If FILENAME is nil, describe current directory (`default-directory').
If FILENAME is the name of an autofile bookmark and you use library
`Bookmark+', then show also the bookmark information (tags etc.).  In
this case, a prefix arg shows the internal form of the bookmark.

In Lisp code:

Non-nil optional arg INTERNAL-FORM-P shows the internal form.
Non-nil optional arg NO-ERROR-P prints an error message but does not
 raise an error."
  (interactive "FDescribe file: \nP")
  (unless filename (setq filename default-directory))
  (help-setup-xref `(describe-file ,filename ,internal-form-p ,no-error-p) (interactive-p))
  (let ((attrs  (file-attributes filename))
        ;; Functions `bmkp-*' are defined in `bookmark+.el'.
        (bmk   (and (fboundp 'bmkp-get-autofile-bookmark)  (bmkp-get-autofile-bookmark filename))))
    (if (not attrs)
        (if no-error-p
            (message "Cannot open file `%s'" filename)
          (error "Cannot open file `%s'" filename))
      (let* ((type             (nth 0 attrs))
             (numlinks         (nth 1 attrs))
             (uid              (nth 2 attrs))
             (gid              (nth 3 attrs))
             (last-access      (nth 4 attrs))
             (last-mod         (nth 5 attrs))
             (last-status-chg  (nth 6 attrs))
             (size             (nth 7 attrs))
             (permissions      (nth 8 attrs))
             ;; Skip 9: t iff file's gid would change if file were deleted and recreated.
             (inode            (nth 10 attrs))
             (device           (nth 11 attrs))
             (help-text
              (concat
               (format "`%s'\n%s\n\n" filename (make-string (+ 2 (length filename)) ?-))
               (format "File Type:                       %s\n"
                       (cond ((eq t type) "Directory")
                             ((stringp type) (format "Symbolic link to `%s'" type))
                             (t "Normal file")))
               (format "Permissions:                %s\n" permissions)
               (and (not (eq t type)) (format "Size in bytes:              %g\n" size))
               (format-time-string
                "Time of last access:        %a %b %e %T %Y (%Z)\n" last-access)
               (format-time-string
                "Time of last modification:  %a %b %e %T %Y (%Z)\n" last-mod)
               (format-time-string
                "Time of last status change: %a %b %e %T %Y (%Z)\n" last-status-chg)
               (format "Number of links:            %d\n" numlinks)
               (format "User ID (UID):              %s\n" uid)
               (format "Group ID (GID):             %s\n" gid)
               (format "Inode:                      %S\n" inode)
               (format "Device number:              %s\n" device))))
        (with-output-to-temp-buffer "*Help*"
          (when bmk
            (if internal-form-p
                (let* ((bname     (bookmark-name-from-full-record bmk))
                       (bmk-defn  (format "Bookmark `%s'\n%s\n\n%s"
                                          bname   (make-string (+ 11 (length bname)) ?-)
                                          (pp-to-string bmk))))
                  (princ bmk-defn) (terpri) (terpri))
              (princ (bmkp-bookmark-description bmk 'NO-IMAGE)) (terpri) (terpri)))
          (princ help-text))
        help-text))))                   ; Return displayed text.

;;;###autoload
(defun describe-keymap (keymap)
  "Describe bindings in KEYMAP, a variable whose value is a keymap.
Completion is available for the keymap name."
  (interactive
   (list (intern
          (completing-read
           "Keymap: " obarray
           (lambda (m) (and (boundp m) (keymapp (symbol-value m))))
           t nil 'variable-name-history))))
  (unless (and (symbolp keymap) (boundp keymap) (keymapp (symbol-value keymap)))
    (error "`%S' is not a keymapp" keymap))
  (let ((name  (symbol-name keymap))
        (doc   (documentation-property keymap 'variable-documentation)))
    (help-setup-xref (list #'describe-keymap keymap) (interactive-p))
    (with-output-to-temp-buffer "*Help*"
      (princ name) (terpri)
      (princ (make-string (length name) ?-)) (terpri) (terpri)
      (when doc (princ doc) (terpri) (terpri))
      ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
      (with-current-buffer "*Help*"
        (insert (substitute-command-keys (concat "\\{" name "}")))))))


;; REPLACES ORIGINAL in `help.el':
;; 1. Preferred candidate is `symbol-nearest-point'.
;; 2. Must be a command, not just a function.
;; 3. Calls `remove-help-window'.
;;
;;;###autoload
(defun where-is (definition &optional insert)
  "Give keyboard/menu/mouse sequences that invoke specified command.
Argument DEFINITION is a command definition, usually a symbol with a
function definition.  Default candidate is: preferably the
`symbol-nearest-point', or else the innermost function call
surrounding point (`function-called-at-point').
Non-nil prefix arg INSERT means insert the message in the buffer."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Where is command: " obarray 'commandp t
                                    nil nil (and fn (symbol-name fn)) t)))))
  (remove-help-window)
  (let* ((keys             (where-is-internal definition overriding-local-map nil nil))
         (keys1            (mapconcat (if (fboundp 'naked-key-description)
                                          #'naked-key-description
                                        #'key-description)
                                      keys ", "))
         (standard-output  (if insert (current-buffer) t)))
    (if insert
        (if (> (length keys1) 0)
            (princ (format "%s (%s)" keys1 definition))
          (princ (format "M-x %s RET" definition)))
      (if (> (length keys1) 0)
          (princ (format "`%s' is on `%s'" definition keys1))
        (princ (format "`%s' is not on any key" definition)))))
  nil)


;; REPLACES ORIGINAL in `help.el':
;; Lets you complete the library name against string variables.
;; Calls `remove-help-window'.
;;
;;;###autoload
(defun locate-library (library &optional nosuffix path interactive-call)
  "Show the full path name of Emacs library LIBRARY.
This command searches the directories in your `load-path' like
`M-x load-library' to find the file that would be loaded by
`M-x load-library RET LIBRARY RET'.

Optional second arg NOSUFFIX non-nil means don't add suffixes `.elc'
or `.el' to the specified name LIBRARY (like calling `load' instead of
`load-library').

If the optional third arg PATH is specified, that list of directories
is used instead of `load-path'.

When called from a program, the file name is normally returned as a
string.  When run interactively, the argument INTERACTIVE-CALL is t,
and the file name is displayed in the echo area."
  (interactive (list (if (fboundp 'icicle-read-string-completing)
                         (icicle-read-string-completing "Locate library: ")
                       (read-string "Locate library: "))
                     nil nil t))
  (let (result)
    (catch 'answer
      (mapcar
       (lambda (dir)
         (mapcar (lambda (suf)
                   (let ((try  (expand-file-name (concat library suf) dir)))
                     (when (and (file-readable-p try)
                                (null (file-directory-p try)))
                       (setq result  try)
                       (message "Library is file `%s'." try)
                       (throw 'answer try))))

                 (if nosuffix
                     '("")
                   '(".elc" ".el" "")
;;; load doesn't handle this yet.
;;;         (let ((basic  '(".elc" ".el" ""))
;;;               (compressed '(".Z" ".gz" "")))
;;;           ;; If autocompression mode is on,
;;;           ;; consider all combinations of library suffixes
;;;           ;; and compression suffixes.
;;;           (if (rassq 'jka-compr-handler file-name-handler-alist)
;;;               (apply 'nconc
;;;                      (mapcar (lambda (compelt)
;;;                                (mapcar (lambda (baselt)
;;;                                          (concat baselt compelt))
;;;                                        basic))
;;;                              compressed))
;;;             basic))
                   )))
       (or path load-path)))
    (and interactive-call
         (if result
             (message "Library is file `%s'" result)
           (message "No library `%s' in search path." library)))
    (remove-help-window)
    result))

;;;###autoload
(defun view-emacs-lisp-news ()
  "Display information on recent changes to Emacs Lisp."
  (interactive)
  (message "Looking for Emacs Lisp Changes file...")
  (find-file-read-only-other-window (expand-file-name "LNEWS" data-directory))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs Lisp Changes file...done"))

;;;###autoload
(defun save-*Help*-buffer ()
  "Rename *Help* buffer as new buffer *Help*<N>, N=2,3...."
  (interactive)
  (let ((notifying-user-of-mode  nil)    ; No msg on mode (in `misc-fns.el').
        (saved-help              (buffer-name (generate-new-buffer "*Help*"))))
    (save-excursion
      (set-buffer "*Help*")
      (copy-to-buffer saved-help (point-min) (point-max))
      (when (interactive-p)
        (message "Saved contents of *Help* buffer to buffer %s."
                 saved-help)))))

(defun help-on-click/key-lookup (key &optional pp-key where)
  "Look up information on KEY via `describe-key' and `info'.
Optional args PP-KEY and WHERE are strings naming KEY and its type.
Their defaults are KEY's `key-description' and \"Key sequence\".
Function `Info-goto-emacs-key-command-node' is used to look up KEY."
  (sit-for 0 200);; HACK to fix bug if click on scroll bar in `help-on-click/key'.
  (setq where   (or where "Key sequence ")
        pp-key  (or pp-key (if (fboundp 'naked-key-description)
                               (naked-key-description key)
                             (key-description key))))
  (let* ((described-p  (if (fboundp 'naked-key-description)
                           (naked-key-description key)
                         (key-description key)))
         ;; The version of `Info-goto-emacs-key-command-node' defined in `info+20.el' returns
         ;; non-nil if Info doc is found.  The standard version defined `info.el' will not.
         (documented-p (Info-goto-emacs-key-command-node key))) ; nil if have only std version
    (when (and (not documented-p)(get-buffer-window "*info*" 'visible)) (Info-exit))
    (cond ((and described-p documented-p)
           (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
           (message "%s`%s': summary in *Help* buffer; doc in *info* buffer."
                    where pp-key))
          (described-p
           (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
           (message "%s`%s': summary in *Help* buffer." where pp-key))
          (documented-p
           (message "%s`%s': doc in *info* buffer." where pp-key))
          (t
           (message "%s`%s' is undefined." where pp-key)))))

;;;###autoload
(defun help-on-click/key (key)
  "Give help on a key/menu sequence or object clicked with the mouse.
The object can be any part of an Emacs window or a name appearing in a
buffer.  You can do any of the following:

    type a key sequence (e.g. `C-M-s')
    choose a menu item (e.g. [menu-bar files open-file])
    click on a scroll bar
    click on the mode line
    click in the minibuffer
    click on an Emacs-related name in a buffer: apropos is called
    click anywhere else in a buffer: its modes are described

Help is generally provided using `describe-key' and the Emacs online
manual (via `Info-goto-emacs-key-command-node').  If no entry is found
in the index of the Emacs manual, then the manual is searched from the
beginning for literal occurrences of KEY.

For example, the KEY `C-g' is not in the index (for some reason), so
the manual is searched.  (Once an occurrence is found, you can
repeatedly type `s' in *Info* to search for additional occurrences.)

If you click on a name in a buffer, then `apropos-documentation' and
`apropos' are used to find information on the name.  These functions
are not used when you do something besides click on a name.

If you click elsewhere in a buffer other than the minibuffer, then
`describe-mode' is used to describe the buffer's current mode(s)."
  (interactive "kClick mouse on something or type a key sequence.")
  (let ((temp-buffer-show-function  'switch-to-buffer-other-window)
        (font-lock-verbose          nil)
        (global-font-lock-mode      nil))
    ;; DEBUG (message "KEY: `%s'" key)(sit-for 4) ; DEBUG
    (cond ((stringp key)
           (help-on-click/key-lookup key))
          (t                            ; Vector.
           (let ((type  (aref key 0)))
             (cond ((or (symbolp type)(integerp type))
                    (cond ((eq 'mode-line type) ; Click on the mode line.
                           (Info-goto-node "(emacs)Mode Line")
                           (message "Mode line: decribed in *info* buffer."))
                          (t            ; Normal key sequence.
                           (help-on-click/key-lookup key))))
                   ((eq 'menu-bar (car type))

                    (help-on-click/key-lookup key (aref key (1- (length key))) "Menu item "))
                   ((not (eq 'down (car (event-modifiers (car type))))) ; e.g. mouse menus
                    (help-on-click/key-lookup key))
                   (t                   ; Mouse click.
                    (setq key  type)
                    (cond ((window-minibuffer-p ; Click in minibuffer.
                            (posn-window (event-start key)))
                           (Info-goto-node "(emacs)Minibuffer")
                           (message "Minibuffer: decribed in *info* buffer."))
                          (t
                           (let ((symb            (save-excursion
                                                    (mouse-set-point key)
                                                    (if (fboundp 'tap-symbol-at-point)
                                                        (tap-symbol-at-point)
                                                      (symbol-at-point))))
                                 (apropos-do-all  t)
                                 (found-doc       nil)
                                 (found           nil)
                                 (symb-regexp     nil))
                             (cond (symb
                                    (message "Looking for info apropos `%s'..." symb)
                                    (when (get-buffer "*Apropos Doc*")
                                      (kill-buffer (get-buffer "*Apropos Doc*")))
                                    (setq found-doc  (apropos-documentation
                                                      (setq symb-regexp
                                                            (regexp-quote
                                                             (setq symb  (format "%s" symb))))))
                                    (when found-doc
                                      (save-excursion
                                        (set-buffer (get-buffer "*Apropos*"))
                                        (rename-buffer "*Apropos Doc*"))
                                      (when (fboundp '1-window-frames-on) ; In `frame-fns.el'.
                                        (let ((frames  (1-window-frames-on "*Apropos Doc*")))
                                          (while frames
                                            (save-window-excursion
                                              (select-frame (car frames))
                                              (rename-frame nil "*Apropos Doc*")
                                              (pop frames))))))
                                    (setq found  (apropos symb-regexp))
                                    ;; Remove empty stuff.
                                    (setq found  (and (consp found) (or (cdr found) (cadr found))))
                                    ;; Remove *Apropos* window that was displayed needlessly.
                                    (unless found (delete-windows-on "*Apropos*"))
                                    (cond
                                      ((and found-doc found)
                                       (message
                                        "See *Apropos* and *Apropos Doc* buffers."))
                                      (found
                                       (message
                                        "See information on `%s' in the *Apropos* buffer."
                                        symb))
                                      (found-doc
                                       (message
                                        "See information on `%s' in the *Apropos Doc* buffer."
                                        symb))
                                      (t
                                       (message
                                        "No information found regarding `%s'."
                                        symb))))
                                   (t   ; User clicked in buffer, but not on a symbol.
                                    (let ((bufname  (buffer-name (current-buffer))))
                                      (describe-mode)
                                      (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
                                      (message
                                       "Mode(s) of buffer `%s' are described in *Help* buffer."
                                       bufname))))))))))))))

;;;###autoload
(defun mouse-help-on-click (event)
  "Give help on an object clicked with the mouse."
  (interactive "e")
  (help-on-click/key (vector event)))

;;;###autoload
(defun mouse-help-on-mode-line-click (event)
  "Give help on the mode line."
  (interactive "e")
  (help-on-click/key (vector 'mode-line event)))

;;;###autoload
(defun pop-to-help-toggle ()
  "Pop to buffer *Help* or back to the buffer that sent you to *Help*."
  (interactive)
  (let ((orig-buf                   (and (buffer-live-p help-origin-buffer)
                                         (get-buffer help-origin-buffer)))
        (w32-grab-focus-on-raise    t)
        (win32-grab-focus-on-raise  t)) ; Older name.
    (if (string-match "*Help*" (buffer-name))
        (cond ((not orig-buf)
               (error "No buffer to return to"))
              ((string-match "Minibuf" (buffer-name orig-buf)) ; No `minibufferp' in Emacs 20.
               (select-frame-set-input-focus
                (window-frame (select-window (minibuffer-window)))))
              (t
               (pop-to-buffer orig-buf)))
      (setq help-origin-buffer  (current-buffer))
      (pop-to-buffer "*Help*"))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'help+20)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; help+20.el ends here
#+end_src

** setup-keys.el

#+call: hash() :exports none

#+RESULTS:
: 20210601222930469855200

#+name: 20210601222930469855200
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; setup-keys.el --- Some key bindings.
;;
;; Filename: setup-keys.el
;; Description: Some key bindings.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2021, Drew Adams, all rights reserved.
;; Created: Fri Apr  2 12:34:20 1999
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Feb  8 19:07:58 2021 (-0800)
;;           By: dradams
;;     Update #: 1361
;; URL: https://www.emacswiki.org/emacs/download/setup-keys.el
;; Keywords: mouse, keyboard, menus, menu-bar
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `apropos', `apropos+', `avoid', `backquote', `bookmark',
;;   `bookmark+', `bookmark+-1', `bookmark+-bmu', `bookmark+-key',
;;   `bookmark+-lit', `button', `bytecomp', `cconv', `cl', `cl-lib',
;;   `cmds-menu', `col-highlight', `color', `crosshairs', `cus-edit',
;;   `cus-face', `cus-load', `cus-start', `cus-theme', `custom',
;;   `doremi', `doremi-cmd', `doremi-frm', `easymenu', `faces',
;;   `faces+', `fit-frame', `font-lock', `font-lock+', `frame-cmds',
;;   `frame-fns', `gv', `help+', `help-fns', `help-fns+',
;;   `help-macro', `help-macro+', `help-mode', `hexrgb', `highlight',
;;   `highlight-symbol', `hl-line', `hl-line+', `info', `info+',
;;   `isearch+', `isearch-prop', `iso-transl', `kmacro', `macroexp',
;;   `menu-bar', `menu-bar+', `misc-cmds', `misc-fns', `mouse',
;;   `mouse+', `mwheel', `naked', `palette', `pp', `pp+',
;;   `radix-tree', `replace', `replace+', `ring', `second-sel',
;;   `strings', `syntax', `text-mode', `thingatpt', `thingatpt+',
;;   `timer', `vline', `w32browser-dlgopen', `wid-edit', `wid-edit+',
;;   `widget', `zones'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Some key bindings.
;;
;;  Think of this library more as an extension to your init file
;;  (~/.emacs) than as a true library.  It makes changes to your Emacs
;;  key bindings.  If you want only some of the bindings that are
;;  defined here, then either modify this file for your own use or
;;  load it and then modify selected bindings afterward.
;;
;;  The user options defined here are not customizable using Customize
;;  (they are not defined using `defcustom').  They are used only
;;  once, when this file is loaded - it makes no sense to change their
;;  values after this file is loaded.  To change their behavior from
;;  the default, set them in your init file before loading this
;;  library.
;;
;;  For example, if you do not want to substitute command
;;  `kill-buffer-and-its-windows' for command `kill-buffer' in all
;;  interactive uses, then put this in your init file *before* loading
;;  library `setup-keys':
;;
;;  (setq sub-kill-buffer-and-its-windows nil) ; Keep `kill-buffer'.
;;
;;  If you also load library `menu-bar+', then load it *before*
;;  loading library `setup-keys'.
;;
;;  User options defined here:
;;
;;    `sub-*-of-line', `sub-delete-windows-for',
;;    `sub-kill-buffer-and-its-windows', `sub-pp-evals',
;;    `sub-query-replace-w-options', `sub-quit-window-delete',
;;    `sub-recenter-top-bottom', `sub-transpose-sexps'.
;;
;;  Other variables defined here:
;;
;;    `comparison-map', `doremi-map'.
;;
;;  Functions defined here:
;;
;;    `remap-command'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2021/02/08 dadams
;;     Renamed to-indentation-repeat-(back|for)ward to (back|forward)-to-indentation+.
;; 2020/01/03 dadams
;;     Applied renamings from thing-cmd.el:
;;       mark-thing to select-things, cycle-thing-region to cycle-select-something.
;; 2018/11/09 dadams
;;     Change binding of to-indentation-repeat-backward to M-p.
;; 2018/09/22 dadams
;;     Use tear-off-window, not mouse-* (aliased), now in mouse+.el, not in frame-cmds.el.
;; 2018/09/14 dadams
;;     Added: sub-clone-frame.  Use it.
;; 2018/03/03 dadams
;;     Removed binding of <delete> to kill-line.
;; 2017/09/10 dadams
;;     Change binding of 1on1-fit-minibuffer-frame in minibuffer keymaps to M-up from C-o.
;; 2016/11/02 dadams
;;     Added: sub-transpose-sexps.
;;     Remap transpose-sexps to reversible-transpose-sexps, if sub-transpose-sexps.
;; 2016/09/18 dadams
;;     Applied renaming of secondary-dwim to secondary-yank|select|move|swap.
;; 2016/07/19 dadams
;;     Bound M-m to to-indentation-repeat-backward and M-n to to-indentation-repeat-forward.
;; 2016/01/24 dadams
;;     Bound C-x 5 1 to tear-off-window.
;; 2015/06/30 dadams
;;     Changed highlight-symbol-* bindings to f9 from f11.
;;     Replaced f12 by f8.
;; 2015/04/02 dadams
;;     Corrected command names for ni-narrow-to-*.
;; 2015/03/15 dadams
;;     Added: remap-command, sub-quit-window-delete.
;;     Remap quit-window to quit-window-delete, if sub-quit-window-delete.
;; 2014/11/28 dadams
;;     Bind compare-windows-repeat instead of compare-windows, if available.
;; 2014/10/29 dadams
;;     Bind (next|previous)-buffer-repeat.
;; 2014/05/23 dadams
;;     Bind narrow-indirect.el commands.
;; 2014/05/19 dadams
;;     If use mouse+.el then get rid of Emacs 24+ minibuffer.el's mouse-1 in echo area.
;;     Consolidate two eval-after-load's for mouse+.
;; 2014/03/12 dadams
;;     Bind C-M-^ to up-list, i.e., forward direction.
;; 2013/11/18 dadams
;;     Bind C-x C-; to comment-region-lines instead of comment-region.
;;     Do not require simple+.el.
;; 2013/11/07 dadams
;;     Bind hlt-highlight-enclosing-list to C-M-S.
;; 2013/10/23 dadams
;;     Bind C-x t s to either doremi-custom-themes+ or doremi-color-themes+.
;; 2013/09/15 dadams
;;     Do not bind help-on-click/key here.  Do not require help+(20).el for that.
;; 2013/09/01 dadams
;;     Added remapping of undo to undo-repeat.
;; 2013/08/23 dadams
;;     Soft-require highlight-symbol.el (Emacs 22+).  Bind its commands to f11 (+ modifiers).
;; 2013/07/25 dadams
;;     Invoke find-function-setup-keys.
;; 2013/07/05 dadams
;;     Bind move-frame-to-screen-top-left to C-S-home.
;; 2013/04/21 dadams
;;     Bind zoom-in/out to C-x +, C-x -, C-x =, C-x 0.
;; 2013/03/06 dadams
;;     Bind C-x C-M-SPC to set-secondary-start, C-x C-M-RET to secondary-save-then-kill.
;; 2013/01/17 dadams
;;     Added bindings for move-frame-to-screen-(top|bottom|left|right).
;; 2013/01/02 dadams
;;     Bound C-o also in minibuffer-(inactive-mode|local-(isearch|shell-command))-map.
;; 2012/12/24 dadams
;;     Added bindings for visual-line-mode line movements.
;; 2012/08/27 dadams
;;     Treat Emacs 24+ insert-char the same as ucs-insert (old name).
;; 2012/07/08 dadams
;;     Bind C-mouse-1 to ignore, so don't see error msg on up event.
;; 2012/07/02 dadams
;;     Bind find-library-other-window to C-x 4 l.
;; 2012/06/02 dadams
;;     If ucs-cmds.el is loaded, bind C-x 8 RET to ucsc-insert, if Emacs 23+.
;; 2011/11/12 dadams
;;     Vars sub-*: Removed (when (fboundp '*)...) wrapper - define always.  But mention in doc
;;       string that has no effect unless library loaded.
;; 2011/07/25 dadams
;;     Use eval-after-load where appropriate (e.g. instead of featurep/fboundp/boundp).
;; 2010/04/22 dadams
;;     Bound C-M-y to isearch-yank-secondary in isearch-mode-map.
;; 2010/02/24 dadams
;;     Bound C-; to iedit-mode, globally and in isearch-mode-map.
;; 2010/02/20 dadams
;;     Bound framemove keys: M-S-(up|down|left|right).
;; 2009/11/07 dadams
;;     Bound doremi-face-bg+ to k.  Applied doremi cmd renamings (added +).
;; 2009/08/26 dadams
;;     Changed binding of region-to-file from `C-x a' to C-x M-f, due to abbrev keys conflict.
;; 2009/07/26 dadams
;;     Fixed typo: prev-buffer -> previous-buffer.
;; 2009/06/25 dadams
;;     Use renaming: yank-secondary-or-swap-w-region to secondary-dwim.
;; 2009/06/11 dadams
;;     Bind zoom-(in|out), not zoom-frm-(in|out).
;;     Don't bind M-s if Emacs 23+.
;; 2009/05/17 dadams
;;     Updated to reflect thumb-frm.el name changes.
;; 2009/04/08 dadams
;;     Use revert-buffer-no-confirm, if defined.
;; 2009/04/06 dadams
;;     Changed binding of revert-buffer from S-f1 to f5 (a la MS Windows).
;; 2009/01/06 dadams
;;     Move delete-window from C-x C-a to C-x C-z, to avoid conflict with gud.
;;      Replaces std binding for iconify-or-deiconify-frame.
;; 2008/11/08 dadams
;;     Bind swiss-move-line-up/down to S-prior/S-next.
;; 2008/10/19 dadams
;;     Bind mouse-2 in ctl-x-map to ignore, so hlt-highlighter works on down-mouse-2.
;; 2008/08/17 dadams
;;     Made zoom-frm-(in|out) bindings portable, and make C- bindings work for Emacs 20, 21.
;; 2008/08/14 dadams
;;     Bound C-x C-a to delete-window, so you can do it with one hand.
;; 2008/08/07 dadams
;;     Bound zoom-frm-(in|out) to C-wheel-(down|up).
;; 2008/08/06 dadams
;;     Bind bm-toggle, bm-next, bm-previous to S-f3, C-f3, M-f3, not C-f3, f3, S-f3.
;; 2008/05/23 dadams
;;     Bound yank-pop-commands to M-y.  Soft-require second-sel.el.
;;     Soft-require second-sel.el.
;; 2008/05/06 dadams
;;     Renamed yank-secondary-or-convert-primary to yank-secondary-or-swap-w-region.
;; 2008/05/03 dadams
;;     Bind yank-secondary-or-convert-primary, not yank-secondary, to C-M-y.
;; 2008/03/19 dadams
;;     Don't bind C-o in completion maps if they inherit from minibuffer-local-map.
;; 2008/03/06 dadams
;;     Removed binding for iconify-everything - too easy to hit by mistake.
;; 2008/03/02 dadams
;;     Removed describe-file binding (done now in help-fns+.el and help+20.el).
;; 2007/12/14 dadams
;;     Require help+20.el for Emacs 20.  Require (new) help+.el for Emacss 22.
;; 2007/12/02 dadams
;;     Bound describe-face to C-h C-M-f.
;; 2007/11/21 dadams
;;     Bound C-o in minibuffer maps to 1on1-fit-minibuffer-frame.
;; 2007/11/06 dadams
;;     Added: sub-recenter-top-bottom.  Substituted recenter-top-bottom for recenter binding.
;; 2007/11/01 dadams
;;     Changed C-x t w from doremi-frame-width to doremi-window-height.
;; 2007/10/13 dadams
;;     Bound bm.el keys to [f3] with modifiers.
;; 2007/09/28 dadams
;;     Bound lisp-spell-symbol to M-#.
;; 2007/09/24 dadams
;;     Bound mark-buffer-(before|after)-point.
;; 2007/09/19 dadams
;;     Removed bindings for goto-previous(-global)-mark.
;; 2007/07/15 dadams
;;     Changed binding of cycle-thing-region to M-@.
;; 2007/06/04 dadams
;;     Removed sub-customize-other window (RMS's bug fix was implemented).
;; 2007/06/02 dadams
;;     Renamed: highlight to hlt-highlight,
;;              highlight-(highlighter|eraser) to hlt-(highlighter|eraser),
;;              highlight-(next|previous)-* to hlt-(next|previous)-*.
;; 2007/04/06 dadams
;;     Changed bindings of fisheye-(next|previous)-frame.
;; 2007/04/02 dadams
;;     Bound goto-longest-line to C-x L.
;; 2007/03/17 dadams
;;     Bound highlight-(next|previous)-highlight, highlight-eraser.
;; 2007/03/16 dadams
;;     Bound highlight-with-marker.  Protect with fboundp.
;; 2007/02/03 dadams
;;     Fixed mark-ring binding.  Thx to Fidel Salas.
;; 2007/01/27 dadams
;;     Bound S-down-mouse-2 to mouse-scan-lines-or-M-:, instead of mouse-M-:.
;; 2007/01/13 dadams
;;     Bound C-h M-f to describe-file.
;; 2006/11/04 dadams
;;     Bound S-down-mouse-2 to mouse-M-:.
;; 2006/11/03 dadams
;;     Bound down-mouse-2 to mouse-flash-position-or-M-x, not mouse-flash-position.
;; 2006/09/12 dadams
;;     Replaced [pause] by [f12] for C-x 8 synonym.  ([pause] is used by Icicles.)
;; 2006/09/08 dadams
;;     Bound crosshairs-mode to C-+.
;; 2006/08/22 dadams
;;     Replaced sub-remove-window by sub-delete-windows-for.
;; 2006/08/15 dadams
;;     Removed C-f1 binding of kill-buffer.
;; 2006/08/11 dadams
;;     Bound mouse-flash-position to down-mouse-2.
;; 2006/07/30 dadams
;;     Added bindings for mark-thing and cycle-thing-region.
;; 2006/05/26 dadams
;;     Clarified commentary.
;;     foldout-mouse-modifiers: Use setq, not defvar.
;; 2006/05/16 dadams
;;     Removed Icicles bindings - use new library icicles-keys.el instead.
;; 2006/03/01 dadams
;;     Bound icicle-complete-thesaurus-entry to C-c /.
;; 2006/01/24 dadams
;;     Bound icicle-execute-extended-command.
;; 2006/01/19 dadams
;;     Added sub-*-of-line.  Use it with move-*-of-line, if Emacs 22.
;; 2006/01/04 dadams
;;     Bound other-window-or-frame to C-x o.
;; 2005/12/13 dadams
;;     Bound delete-other-frames to C-x 4 1.
;; 2005/12/03 dadams
;;     Changed bindings of thumb-frm.el commands and show-hide.
;; 2005/11/18 dadams
;;     Bound mouse-4 to help-go-back in help-mode-map, and M-` to icicle-execute-menu-command.
;; 2005/10/27 dadams
;;     Renamed sub-icicle-buffer to sub-icicle-commands.  Bound icicle-find-file*.
;; 2005/10/16 dadams
;;     Bound icicle-compilation-search in compilation-minor-mode-map.  Bound grep in grep.
;; 2005/09/02 dadams
;;     Added sub-icicle-buffer, and substituted for switch-to-buffer*.
;;     Protected sub-* by fboundp.
;; 2005/08/13 dadams
;;     Added binding for icicle-execute-menu-command.
;; 2005/08/02 dadams
;;     Added binding for doremi-all-faces-fg.
;; 2005/05/29 dadams
;;     Added move-frame-* bindings.
;; 2005/05/17 dadams
;;     Updated to work with Emacs 22.x.
;; 2005/05/06 dadams
;;     Added commented-out binding for thumbify-frame-upon-event, as a model.
;; 2005/01/26 dadams
;;     Commented out (w32-register-hot-key [A-tab]).
;;     Removed ###autoload for defvars.
;; 2005/01/20 dadams
;;     Removed sub-exit-with-confirmation.
;; 2005/01/09 dadams
;;     Renamed: doremi-bg-rgb to doremi-bg, doremi-face-fg-rgb to doremi-face-fg.
;;     Changed some doremi bindings.
;; 2005/01/02 dadams
;;     Changed binding of region-to-file because `C-x w' conflicted with hi-lock.
;;     Added bindings for doremi-mark and doremi-global-mark; changed for doremi-bookmarks.
;; 2004/12/28 dadams
;;     Added doremi-face-fg-rgb binding.  Changed binding: doremi-font.
;; 2004/12/26 dadams
;;     Added thumb-frm.el bindings.
;; 2004/11/24 dadams
;;     (w32-register-hot-key [A-tab])
;; 2004/11/21 dadams
;;     Added [C-pause], [M-pause] bindings for prev-buffer, next-buffer.
;; 2004/11/20 dadams
;;     Refined to deal with Emacs 21 < 21.3.50 (soon to be 22.x)
;; 2004/11/16 dadams
;;     Added substitute-key-definition '*-of-line '*-of-line+.
;; 2004/10/13 dadams
;;     These were added for Emacs 21 also: replace+.el, buff-menu+.el.
;; 2004/10/02 dadams
;;     Per request by RMS:
;;     Renamed grow-frame-height and grow-frame-width to enlarge-frame
;;     and enlarge-frame-horizontally, respectively.
;;     Added shrink-frame and shrink-frame-horizontally.
;; 2004/09/21 dadams
;;     Don't require stuff that's not yet ready or inappropriate for Emacs 21.
;; 2004/09/11 dadams
;;     Bound vertical-line mouse commands.
;;     Added bindings for commands in doremi-frm.el.
;; 2004/08/26 dadams
;;     Changed C-M-up/down/left/right to enlarge-frame* and shrink-frame*.
;; 2004/04/28 dadams
;;     Added C-M-home and C-M-end bindings for beginning- and end-of-defun.
;; 1999/09/03 dadams
;;     Added sub-pp-evals.  Use it to replace eval-* with pp-eval-*.
;; 1999/09/02 dadams
;;     1. Added binding for show-hide.
;;     2. Added vars: sub-exit-with-confirmation,
;;        sub-kill-buffer-and-its-windows, sub-pp-evals,
;;        sub-query-replace-w-options, sub-remove-window.  Use to
;;        protect substitute-key-definition's.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'frame-cmds nil t) ;; (no error if not found): delete-other-frames,
                            ;; delete-windows-for, enlarge-frame*,
                            ;; iconify-everything, iconify/map-frame, move-frame-*,
                            ;; mouse-iconify/map-frame, mouse-remove-window,
                            ;; mouse-show-hide-mark-unmark, other-window-or-frame,
                            ;; show-*Help*-buffer, show-hide, shrink-frame*,
(require 'mouse+ nil t)     ;; (no error if not found):
                            ;; mouse-flash-position, (mouse-)tear-off-window
(require 'highlight nil t) ;; (no error if not found): hlt-highlight, hlt-highlighter,
                           ;; hlt-eraser, hlt-(next|previous)-highlight
(when (fboundp 'define-minor-mode) ;; (no error if not found): *-at-point,
  (require 'highlight-symbol nil t)) ;; *-(next|prev), *-query-replace

(require 'misc-cmds nil t) ;; (no error if not found): beginning-of-line+,
                           ;; end-of-line+, goto-longest-line, kill-buffer-and-its-windows,
                           ;; mark-buffer-after-point, mark-buffer-before-point,
                           ;; recenter-top-bottom, region-to-buffer, region-to-file,
                           ;; back-to-indentation+, forward-to-indentation+, undo-repeat
(require 'second-sel nil t) ;; (no error if not found): secondary-yank|select|move|swap,
                            ;; isearch-yank-secondary, yank-pop-commands,
                            ;; isearch-yank-secondary, set-secondary-start,
                            ;; secondary-save-then-kill
(require 'pp+ nil t) ;; (no error if not found): pp-eval-expression
(require 'fit-frame nil t) ;; (no error if not found):
                           ;; fit-frame, fit-frame-or-mouse-drag-vertical-line
(require 'doremi-frm nil t) ;; (no error if not found): doremi-bg+, doremi-face-fg+,
                            ;; doremi-font+, doremi-frame-font-size+, doremi-frame-configs+,
                            ;; doremi-frame-height+, doremi-frame-horizontally+,
                            ;; doremi-frame-vertically+
(require 'doremi-cmd nil t) ;; (no error if not found): doremi-buffers+, doremi-bookmarks+,
                            ;; doremi-color-themes+, doremi-custom-themes+

(when (< emacs-major-version 21)
  ;; (require 'help+20 nil t) ;; (no error if not found): help-on-click/key
  (require 'unaccent nil t)) ;; (no error if not found): unaccent-region, unaccent-word
;;; (when (> emacs-major-version 21)
;;;   (require 'help+ nil t)) ;; (no error if not found): help-on-click/key
(require 'replace+ nil t)   ;; (no error if not found): query-replace-w-options

;; Quiet the byte compiler.
(defvar grep-mode-map)                  ; Defined in `grep.el'.
(defvar mouse-wheel-down-event)         ; Defined in `mwheel.el'.
(defvar mouse-wheel-up-event)           ; Defined in `mwheel.el'.

;;;-----------------------------

(defun remap-command (old new map &optional oldmap)
  "Bind command NEW in MAP to all keys currently bound to OLD.
If command remapping is available, use that.  Otherwise, bind NEW to
whatever OLD is bound to in MAP, or in OLDMAP, if provided."
  (if (fboundp 'command-remapping)
      (define-key map (vector 'remap old) new) ; Ignore OLDMAP for Emacs 22.
    (substitute-key-definition old new map oldmap)))

(when (boundp 'help-mode-map) (define-key help-mode-map [mouse-4] 'help-go-back))
(when (boundp 'grep-mode-map) (define-key grep-mode-map "g" 'grep)) ; Emacs 22

(autoload 'compare-windows "compare-w"
  "Compare text in current window with text in next window." t)
(autoload 'ediff-buffers "ediff"
  "Run Ediff on a pair of buffers, BUFFER-A and BUFFER-B." t)
(autoload 'ediff-files "ediff"
  "Run Ediff on a pair of files, FILE-A and FILE-B." t)
(autoload 'kill-rectangle "rect"
  "Delete rectangle with corners at point & mark; save as last killed." t)
(autoload 'fill-individual-paragraphs "fill"
  "Fill paragraphs of uniform indentation within the region." t)
(autoload 'ispell-complete-word "ispell"
  "Complete word using letters at point to word beginning using `look'." t)
(autoload 'forward-whitespace "thingatpt" nil t)
(autoload 'forward-symbol "thingatpt" nil t)
(autoload 'dired-jump-other-window "dired-x"
  "Jump to dired buffer corresponding to current buffer, in new window." t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Don't let Windows grap ALT-TAB:
;; (when (eq system-type 'windows-nt) (w32-register-hot-key [A-tab]))

;; Additional definitions for some standard mouse commands:
;; SGI does not pass all ALT-mouse stuff thru to Emacs, so use C-M-mouse also:
(global-set-key [C-M-mouse-1] 'mouse-start-secondary) ; In `mouse.el'.            `C-M-mouse-1'
(global-set-key [C-M-drag-mouse-1] 'mouse-set-secondary) ; In `mouse.el'.
(global-set-key [C-M-down-mouse-1] 'mouse-drag-secondary) ; In `mouse.el'.
(global-set-key [C-M-mouse-3] 'mouse-secondary-save-then-kill) ; `second-sel.el'. `C-M-mouse-3'
(global-set-key [C-M-mouse-2] 'mouse-yank-secondary) ; `mouse+.el' or `mouse.el'  `C-M-mouse-2'

(global-set-key "\C-\M-^" 'up-list)                                              ; `C-M-^'

(eval-after-load "mouse+"
  '(progn                               ; Highlight yank position or call `M-x' in echo area.
    (global-set-key [down-mouse-2]   'mouse-flash-position-or-M-x)               ; `mouse-2'
    ;; Highlight line or `M-:'.
    (global-set-key [S-down-mouse-2]      'mouse-scan-lines-or-M-:)              ; `S-mouse-2'
    (global-set-key [mode-line C-mouse-1] 'tear-off-window)            ; `<mode-line> C-mouse-1'
    (define-key ctl-x-5-map "1"           'tear-off-window)                      ; `C-x 5 1'
    (when (> emacs-major-version 23)
      (define-key minibuffer-inactive-mode-map [down-mouse-1] nil)               ; `mouse-1'
      (define-key minibuffer-inactive-mode-map [mouse-1] nil))))                 ; in echo area

(eval-after-load "second-sel"
  '(progn
    (global-set-key (kbd "C-M-y")  (if (fboundp 'secondary-yank|select|move|swap)
                                       'secondary-yank|select|move|swap
                                     'secondary-dwim))                           ; `C-M-y'
    (define-key esc-map "y"                     'yank-pop-commands)              ; `M-y'
    (define-key isearch-mode-map (kbd "C-M-y")  'isearch-yank-secondary)         ; `C-M-y'
    (global-set-key (kbd "C-x C-M-SPC")         'set-secondary-start)            ;`C-x C-M-SPC'
    (global-set-key (kbd "C-x C-M-<return>")    'secondary-save-then-kill)))     ;`C-x C-M-RET'

(eval-after-load "narrow-indirect"
  '(progn
    (define-key ctl-x-4-map "nd" 'ni-narrow-to-defun-indirect-other-window)      ; `C-x 4 n d'
    (define-key ctl-x-4-map "nn" 'ni-narrow-to-region-indirect-other-window)     ; `C-x 4 n n'
    (define-key ctl-x-4-map "np" 'ni-narrow-to-page-indirect-other-window)))     ; `C-x 4 n p'

;; Because C-M- is being used for secondary.
(eval-after-load "foldout" '(setq foldout-mouse-modifiers '(meta shift)))

(eval-after-load "oneonone" ; Bind `1on1-fit-minibuffer-frame' to `M-up' in minubuffer maps.
  '(when (framep 1on1-minibuffer-frame) ; Standalone minibuffer frame.
    (define-key minibuffer-local-map [(meta up)] '1on1-fit-minibuffer-frame)
    (unless (eq minibuffer-local-map (keymap-parent minibuffer-local-completion-map))
      (define-key minibuffer-local-must-match-map [(meta up)] '1on1-fit-minibuffer-frame)
      (define-key minibuffer-local-completion-map [(meta up)] '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-filename-completion-map)
      (define-key minibuffer-local-filename-completion-map [(meta up)]
        '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-must-match-filename-map) ; Emacs 22
      (define-key minibuffer-local-must-match-filename-map [(meta up)]
        '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-filename-must-match-map) ; Emacs 23+
      (define-key minibuffer-local-filename-must-match-map [(meta up)]
        '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-isearch-map)
      (unless (eq minibuffer-local-map (keymap-parent minibuffer-local-isearch-map))
        (define-key minibuffer-local-isearch-map [(meta up)] '1on1-fit-minibuffer-frame)))
    (when (boundp 'minibuffer-local-shell-command-map)
      (unless (eq minibuffer-local-map (keymap-parent minibuffer-local-shell-command-map))
        (define-key minibuffer-local-shell-command-map [(meta up)] '1on1-fit-minibuffer-frame)))
    (when (boundp 'minibuffer-inactive-mode-map)
      (define-key minibuffer-inactive-mode-map [(meta up)] '1on1-fit-minibuffer-frame))))

(eval-after-load "frame-cmds"
  '(progn
    (global-set-key [(meta up)]             'move-frame-up)                      ; `M-up'
    (global-set-key [(meta down)]           'move-frame-down)                    ; `M-down'
    (global-set-key [(meta left)]           'move-frame-left)                    ; `M-left'
    (global-set-key [(meta right)]          'move-frame-right)                   ; `M-right'
    (global-set-key [(meta shift ?v)]       'move-frame-to-screen-top)           ; `M-S-v'
    (global-set-key [(control shift ?v)]    'move-frame-to-screen-bottom)        ; `C-S-v'
    (global-set-key [(control shift prior)] 'move-frame-to-screen-left)          ; `C-S-prior'
    (global-set-key [(control shift next)]  'move-frame-to-screen-right)         ; `C-S-next'
    (global-set-key [(control shift home)]  'move-frame-to-screen-top-left)      ; `C-S-home'
    (global-set-key [(control meta up)]     'shrink-frame)                       ; `C-M-up'
    (global-set-key [(control meta down)]   'enlarge-frame)                      ; `C-M-down'
    (global-set-key [(control meta left)]   'shrink-frame-horizontally)          ; `C-M-left'
    (global-set-key [(control meta right)]  'enlarge-frame-horizontally)         ; `C-M-right'
    ;; Replaces`iconify-or-deiconify-frame'.
    (global-set-key [(control ?z)] 'iconify/map-frame)                           ; `C-z'
    ;; $$$$ (global-set-key [(control ?x) (control ?z)] 'iconify-everything)
    (global-set-key [(shift control meta ?z)] 'show-hide)                        ; `C-M-S-z'
    (global-set-key [C-down-mouse-1]        'mouse-show-hide-mark-unmark)        ; `C-mouse-1'
    (global-set-key [C-mouse-1]            'ignore)
    (global-set-key [S-down-mouse-1]       nil) ; Get rid of `mouse-set-font'.   ; `S-mouse-1'
    ;;(global-set-key [vertical-line mouse-1] 'ignore)
    (global-set-key [vertical-line C-down-mouse-1] 'show-hide)
    ;;(global-set-key [vertical-line C-mouse-1] 'ignore)
    (global-set-key [vertical-line S-down-mouse-1] 'iconify-everything)
    ;;(global-set-key [vertical-line S-mouse-1] 'ignore)
    ;; [mode-line mouse-3] as deletion (Emacs std) is too hazardous.  Iconify instead.
    (global-set-key [mode-line mouse-3]     'mouse-iconify/map-frame)
    (global-set-key [mode-line C-mouse-3]   'mouse-remove-window)))

(eval-after-load "framemove"
  '(progn
    (global-set-key [(shift meta up)]    'fm-up-frame)                           ; `M-S-up'
    (global-set-key [(shift meta down)]  'fm-down-frame)                         ; `M-S-down'
    (global-set-key [(shift meta left)]  'fm-left-frame)                         ; `M-S-left'
    (global-set-key [(shift meta right)] 'fm-right-frame)))                      ; `M-S-right'

(eval-after-load "zoom-frm"             ; `zoom-frm.el' requires `frame-cmds.el'.
  '(progn
    (global-set-key [S-mouse-1] 'zoom-in)                                     ; `S-mouse-1'
    (global-set-key [C-S-mouse-1] 'zoom-out)                                  ; `C-S-mouse-1'
    (global-set-key (if (boundp 'mouse-wheel-down-event)                      ; `C-mouse-wheel'
                        (vector (list 'control mouse-wheel-down-event))
                      [C-mouse-wheel])  ; Emacs 20, 21
     'zoom-in)
    (when (boundp 'mouse-wheel-up-event)
      (global-set-key (vector (list 'control mouse-wheel-up-event)) 'zoom-out))

    (when (fboundp 'text-scale-adjust)  ; Emacs 23+
      (define-key ctl-x-map [(control ?+)] 'zoom-in/out)                         ; `C-x +'
      (define-key ctl-x-map [(control ?-)] 'zoom-in/out)                         ; `C-x -'
      (define-key ctl-x-map [(control ?=)] 'zoom-in/out)                         ; `C-x ='
      (define-key ctl-x-map [(control ?0)] 'zoom-in/out))))                      ; `C-x 0'

;;;   ;; These [nil] bindings are no doubt a HACK, based on an undocumented handy "feature".
;;;   ;; (This works in Emacs 19.34.6, but it doesn't work in Emacs 20.6.)
;;;   ;; In Windows, at least, such a key sequence [nil...] occurs if you click in the
;;;   ;; lower right corner, between the scroll bar and the mode-line.
;;;   (global-set-key [nil down-mouse-1] 'fit-frame)
;;;   (global-set-key [nil mouse-1] 'ignore)
;;;   (global-set-key [nil C-down-mouse-1] 'show-hide)
;;;   (global-set-key [nil C-mouse-1] 'ignore)
;;;   (global-set-key [nil S-down-mouse-1] 'iconify-everything)
;;;   (global-set-key [nil S-mouse-1] 'ignore)

;; These are defined in `fit-frame.el'.
(eval-after-load "fit-frame"
  '(progn
    (global-set-key [(control ?x) (control ?_)] 'fit-frame)                      ; `C-x C-_'
    (global-set-key [vertical-line down-mouse-1] 'fit-frame-or-mouse-drag-vertical-line)))

(eval-after-load "iedit"
  '(progn
    (define-key global-map       (kbd "C-;") 'iedit-mode)                        ; `C-;'
    (define-key isearch-mode-map (kbd "C-;") 'iedit-mode)))

;;; Put *Help* buffer in `help-minor-mode'.
;;(save-excursion (set-buffer (get-buffer-create "*Help*")) (help-minor-mode 1))

;;;; Help mouse-menu.
;;(when (fboundp 'help-mouse-menu)        ; In `help-minor.el'.
;;  (unless (lookup-key (current-global-map) [C-M-S-down-mouse-1])
;;    (global-set-key [C-M-S-down-mouse-1] 'help-mouse-menu)
;;    (global-set-key [C-M-S-mouse-1] 'ignore))
;;  (unless (lookup-key (current-global-map) [C-M-S-down-mouse-2])
;;    (global-set-key [C-M-S-down-mouse-2] 'help-mouse-menu)
;;    (global-set-key [C-M-S-mouse-2] 'ignore))
;;  (unless (lookup-key (current-global-map) [C-M-S-down-mouse-3])
;;    (global-set-key [C-M-S-down-mouse-3] 'help-mouse-menu)
;;    (global-set-key [C-M-S-mouse-3] 'ignore)))

;; Comparisons: windows, buffers, files.
(global-set-key [(control meta ?=)] (if (fboundp 'compare-windows-repeat)
                                        'compare-windows-repeat ; In `misc-cmds.el'.
                                      'compare-windows)) ; In `compare-w.el'.
(defvar comparison-map (lookup-key global-map [?\C-=])
  "Prefix keymap for comparison commands.")
(unless (keymapp comparison-map)
  (setq comparison-map (make-sparse-keymap))
  (global-set-key [(control ?=)] comparison-map)
  (define-key comparison-map "b" 'ediff-buffers) ; In `ediff.el'.                ; `C-= b'
  (define-key comparison-map "e" 'ediff-files) ; In `ediff.el'.                  ; `C-= e'
  (define-key comparison-map "f" 'ediff-files) ; In `ediff.el'.                  ; `C-= f'
  (define-key comparison-map "d" 'diff) ; In `diff+.el'.                         ; `C-= d'
  (define-key comparison-map "w" (if (fboundp 'compare-windows-repeat)           ; `C-= w'
                                     'compare-windows-repeat ; In `misc-cmds.el'.
                                   'compare-windows))) ; In `compare-w.el'.

;; Completions (non-minibuffer).
;(global-set-key "\M-\r" 'complete)      ; Defined in `completion.el':
;(global-set-key [?\C-\r] 'complete)
;(define-key function-key-map [C-return] [?\C-\r])

(eval-after-load "fill"
  '(define-key text-mode-map [(meta ?j)] 'fill-individual-paragraphs))           ; `M-j'

(eval-after-load "ispell"
  '(global-set-key [(meta ?$)] 'ispell-complete-word))                           ; `M-$'

(eval-after-load "thingatpt"
  '(progn
    (global-set-key [(meta ?_)] 'forward-whitespace)                             ; `M-_'
    ;; Emacs 23 co-opts `M-s-' as a prefix key.
    (unless (lookup-key global-map [(meta ?s)])                                  ; `M-s-'
      (global-set-key [(meta ?s)] 'forward-symbol)))) ; Defined in `thingatpt.el'

;; These replace the bindings for `mark-sexp' and `mark-word'.  Defined in `thing-cmds.el'.
(eval-after-load "thing-cmds"
  '(progn
    (global-set-key [(control meta ? )] 'select-things)                          ; `C-M-SPC'
    (global-set-key [(meta ?@)] 'cycle-select-something)))                       ; `M-@'

(eval-after-load "crosshairs"
  '(global-set-key [(control ?+)] 'crosshairs-mode))                             ; `C-+'

(eval-after-load "unaccent"
  '(progn
    (global-set-key [(meta ?\")] 'unaccent-word)                                 ; `M-"'
    (define-key ctl-x-map [\"] 'unaccent-region)))                               ; `C-x "'

;;; Do Re Mi commands
(eval-after-load "doremi-frm"
  '(progn
    (unless (fboundp 'doremi-prefix)
      (defalias 'doremi-prefix (make-sparse-keymap))
      (defvar doremi-map (symbol-function 'doremi-prefix)
        "Keymap for Do Re Mi commands."))
    (define-key global-map "\C-xt" 'doremi-prefix)
    (define-key doremi-map "a" 'doremi-all-faces-fg+) ; "All"                    `C-x t a'
    (define-key doremi-map "c" 'doremi-bg+) ; "Color"                            `C-x t c'
    (define-key doremi-map "f" 'doremi-face-fg+) ; Face"                         `C-x t f'
    (define-key doremi-map "h" 'doremi-frame-height+) ; Height                   `C-x t h'
    (define-key doremi-map "k" 'doremi-face-bg+) ; bacKground"                   `C-x t k'
    (define-key doremi-map "t" 'doremi-font+) ; "Typeface"                       `C-x t t'
    (define-key doremi-map "u" 'doremi-frame-configs+) ; "Undo"                  `C-x t u'
    (define-key doremi-map "x" 'doremi-frame-horizontally+) ; X (abscissa)       `C-x t x'
    (define-key doremi-map "y" 'doremi-frame-vertically+)   ; Y (ordinate)       `C-x t y'
    (define-key doremi-map "z" 'doremi-frame-font-size+))) ; "Zoom"              `C-x t z'

(eval-after-load "doremi-cmd"
  '(progn
    (unless (fboundp 'doremi-prefix)
      (defalias 'doremi-prefix (make-sparse-keymap))
      (defvar doremi-map (symbol-function 'doremi-prefix)
        "Keymap for Do Re Mi commands."))
    (define-key global-map "\C-xt"  'doremi-prefix)
    (define-key doremi-map "b" 'doremi-buffers+) ; Buffer                        `C-x t b'
    (define-key doremi-map "g" 'doremi-global-marks+) ; Global mark              `C-x t g'
    (define-key doremi-map "m" 'doremi-marks+) ; Mark                            `C-x t m'
    (define-key doremi-map "r" 'doremi-bookmarks+) ; `r' for Reading books       `C-x t r'
    (define-key doremi-map "s" (if (fboundp 'doremi-custom-themes+)
                                   'doremi-custom-themes+
                                 'doremi-color-themes+)) ; `s' for color Schemes `C-x t s'
    (define-key doremi-map "w" 'doremi-window-height+))) ; Window                `C-x t w'

(eval-after-load "frame-cmds"
  '(progn
    (unless (fboundp 'doremi-prefix)
      (defalias 'doremi-prefix (make-sparse-keymap))
      (defvar doremi-map (symbol-function 'doremi-prefix)
        "Keymap for Do Re Mi commands."))
    (define-key global-map "\C-xt"  'doremi-prefix)
    (define-key doremi-map "." 'save-frame-config)))                           ; `C-x t .'

(eval-after-load "thumb-frm"
  '(progn
    (global-set-key [(shift mouse-3)]         'thumfr-toggle-thumbnail-frame)  ; `S-mouse-3'
    (global-set-key [(shift control mouse-3)] 'thumfr-thumbify-other-frames)   ; `C-S-mouse-3'
    (global-set-key [(shift control ?z)]      'thumfr-thumbify-other-frames)   ; `C-S-z'
    (global-set-key [(shift control ?n)]      'thumfr-fisheye-next-frame)      ; `C-S-n'
    (global-set-key [(shift control ?p)]      'thumfr-fisheye-previous-frame)  ; `C-S-p'
    (global-set-key [(control meta ?z)]    'thumfr-really-iconify-or-deiconify-frame) ; `C-M-z'
    ;; `e' for eye (fisheye)
    (define-key global-map "\C-xte" 'thumfr-doremi-thumbnail-frames+)          ; `C-x t e'
    ;; Make window-manager "minimize" button thumbify instead of iconify.
    ;; (define-key special-event-map [iconify-frame] 'thumfr-thumbify-frame-upon-event)
    ))

(eval-after-load "ucs-cmds"
  '(when (> emacs-major-version 22)     ; Need Emacs 23+ version of `insert-char'/`ucs-insert'.
    (when (commandp 'insert-char)       ; `ucs-insert' renamed to `insert-char' in Emacs 24.
      (define-key global-map [remap insert-char] 'ucsc-insert))
    (when (fboundp 'ucs-insert)
      (define-key global-map [remap ucs-insert] 'ucsc-insert))))

(define-key help-map "\C-\M-f" 'describe-face)                                 ; `C-h C-M-f'

;; `C-x' stuff.
;;
;; So you can do it with one hand.
(define-key ctl-x-map [(control ?z)] 'delete-window)                           ; `C-x C-z'

(eval-after-load "misc-cmds"
  '(progn
    (define-key ctl-x-map [home] 'mark-buffer-before-point)                    ; `C-x home'
    (define-key ctl-x-map [end]  'mark-buffer-after-point)                     ; `C-x end'
    (define-key ctl-x-map [(control ?\;)] 'comment-region-lines)               ; `C-x C-;'
    (define-key ctl-x-map "\M-f" 'region-to-file)                              ; `C-x M-f'
    (define-key ctl-x-map "L"    'goto-longest-line)                           ; `C-x L'
    (when (fboundp 'undo-repeat) (global-set-key [remap undo] 'undo-repeat))   ; `C-x u' etc.
    (when (fboundp 'next-buffer-repeat)
      (global-set-key [remap previous-buffer] 'previous-buffer-repeat)         ; `C-x left'
      (global-set-key [remap next-buffer]     'next-buffer-repeat))))          ; `C-x right'

;; In `chistory.el'.
(define-key ctl-x-map [(meta ?x)] 'repeat-matching-complex-command)            ; `C-x M-x'
(define-key ctl-x-map "c" 'font-lock-mode)                                     ; `C-x c'

(eval-after-load "frame-cmds"
  '(define-key ctl-x-map "o" 'other-window-or-frame))                          ; `C-x o'

(eval-after-load "highlight"
  '(progn
    (define-key ctl-x-map [(control ?y)] 'hlt-highlight)                       ; `C-x C-y'
    (define-key ctl-x-map [(down-mouse-2)] 'hlt-highlighter)                   ; `C-x mouse-2'
    (define-key ctl-x-map [(mouse-2)] 'ignore)
    (define-key ctl-x-map [(S-down-mouse-2)] 'hlt-eraser)                     ; `C-x S-mouse-2'
    (when (fboundp 'next-single-char-property-change) ; Emacs 21+
      (global-set-key [(shift control ?p)] 'hlt-previous-highlight)            ; `C-S-p'
      (global-set-key [(shift control ?n)] 'hlt-next-highlight))               ; `C-S-n'
    (global-set-key [(control meta shift ?s)] 'hlt-highlight-enclosing-list))) ; `C-M-S'

(eval-after-load "highlight-symbol"
  '(progn
    (global-set-key [(control f9)] 'highlight-symbol-at-point)                 ; `C-f9'
    (global-set-key [f9]           'highlight-symbol-next)                     ; `f9'
    (global-set-key [(shift f9)]   'highlight-symbol-prev)                     ; `S-f9'
    (global-set-key [(meta f3)]    'highlight-symbol-query-replace)))          ; `M-f9'

(eval-after-load "dired-x"
  '(progn
    (define-key ctl-x-map   [(control ?j)] 'dired-jump)                        ; `C-x j'
    (define-key ctl-x-4-map [(control ?j)] 'dired-jump-other-window)))         ; `C-x 4 j'

(eval-after-load "frame-cmds"
  '(progn
    (define-key ctl-x-4-map "1" 'delete-other-frames)                          ; `C-x 4 1'
    (define-key ctl-x-5-map "h" 'show-*Help*-buffer)))                         ; `C-x 5 h'

(eval-after-load "find-func+"           ; Emacs 22+
  '(define-key ctl-x-4-map "l" 'find-library-other-window))                    ; `C-x 4 l'
(find-function-setup-keys)  ;; C-x F, C-x 4 F, C-x 5 F, C-x K, C-x V, C-x 4 V, C-x 5 V

;; [f1] function key.
;;; (eval-after-load "help+"
;;;   ;; Standard binding is `help-command'
;;;   '(global-set-key [f1] 'help-on-click/key))                                   ; `f1'
;;; (eval-after-load "help+20"
;;;   '(global-set-key [f1] 'help-on-click/key))

(eval-after-load "misc-cmds"
  '(global-set-key [C-S-f1] 'region-to-buffer))                                ; `C-S-f1'

(global-set-key [M-S-f1] 'insert-buffer) ; Defined in `simple.el'.             ; `M-S-f1'
;; Defined in `font-lock.el'
(global-set-key [C-M-f1] 'font-lock-fontify-buffer)                            ; `C-M-f1'
(global-set-key [C-M-S-f1] 'rename-buffer)                                     ; `C-M-S-f1'

;; [f3] function key.
(eval-after-load "bm"
  '(progn
    (global-set-key (kbd "<S-f3>") 'bm-toggle)                                 ; `S-f3'
    (global-set-key (kbd "<C-f3>") 'bm-next)                                   ; `C-f3'
    (global-set-key (kbd "<M-f3>") 'bm-previous)))                             ; `M-f3'

;; [f5] function key - a la MS Windows.
(global-set-key [f5] 'revert-buffer)                                           ; `f5'
(eval-after-load "misc-cmds"
  '(global-set-key [f5] 'revert-buffer-no-confirm))                            ; `f5'

;; [insert] key.  [C-insert] is `kill-ring-save'.  [S-insert] is `yank'.
(global-set-key [M-insert] 'yank-pop) ; Defined in `simple.el'.                ; `M-insert'
(global-set-key [C-S-insert] 'insert-buffer) ; Defined in `simple.el'.         ; `C-S-insert'
(global-set-key [M-S-insert] 'yank-rectangle)                                  ; `M-S-insert'
(global-set-key [C-M-insert] 'lisp-complete-symbol)                            ; `C-M-insert'
(global-set-key [C-M-S-insert] 'insert-file)                                   ; `C-M-S-insert'

(eval-after-load "fuzzy-match"
  '(global-set-key "\M-#" 'lisp-spell-symbol))                                 ; `M-#'

;; [delete] key.
(global-set-key [C-delete] 'kill-paragraph) ; Defined in `paragraphs.el'.        `C-delete'
(global-set-key [M-delete] 'kill-ring-save) ; Defined in `simple.el'.            `M-delete'
; Emacs standard: [S-delete] is `kill-region'.
(global-set-key [C-S-delete] 'append-next-kill) ; Defined in `simple.el'.        `C-S-delete'
(global-set-key [M-S-delete] 'kill-rectangle) ; Defined in `rect.el'.            `M-S-delete'
(global-set-key [C-M-delete] 'kill-sexp) ; Defined in `lisp.el'.                 `C-M-delete'
(global-set-key [C-M-S-delete] 'append-to-register) ; Defined in `register.el'.  `C-M-S-delete'

;; [backspace] key.
(global-set-key [C-backspace] 'backward-kill-paragraph) ; In `paragraphs.el'.    `C-backspace'

(eval-after-load "misc-cmds"
  '(global-set-key [C-S-backspace] 'region-to-file))                        ; `C-S-backspace'

(global-set-key [M-S-backspace] 'clear-rectangle) ; Defined in `rect.el'.     `M-S-backspace'
; This was standard in Emacs 20:
(global-set-key [C-M-backspace] 'backward-kill-sexp) ; In  `lisp.el'.         `C-M-backspace'
(global-set-key [C-M-S-backspace] 'copy-to-register) ; In `register.el'.      `C-M-S-backspace'

;; [pause] / [break] key:
;; NOTE: On Windows, [C-pause] is considered to be [C-cancel].  Still true for XP?

;; Better than the standard bindings `C-x <right>' and `C-x <right>',
;; because you can hold these down to repeat: cycle through buffers.
(when (fboundp 'next-buffer)            ; Emacs 21+.
  (global-set-key [C-pause] 'previous-buffer)                                   ; `C-pause'
  (global-set-key [M-pause] 'next-buffer))                                      ; `M-pause'

;; `iso-transl.el' is needed to use an ISO prefix key (e.g. `C-x 8'. [f8]).
;; It defines `key-translation-map'.
(require 'iso-transl)
;;;@@@Emacs20 ;; This lets users do `[f8] C-h]' for help on ISO chars.
;;;@@@Emacs20 (autoload 'help-iso-prefix "help+"
;;;@@@Emacs20   "Show commands bound to ISO (pseudo-)prefix key sequences." t)

  ;; Make [f8] key be a synonym for `C-x 8'. (Use [f8] as a compose key.)
(define-key key-translation-map [f8]   ; See `iso-transl.el'.                   ; `f8'
  (lookup-key key-translation-map "\C-x8"))

;; Make [f8] key be a synonym for `C-x 8' for isearch too.
;; This lets you search for accented chars using [f8].
(define-key isearch-mode-map [f8] nil)
;;;@@@Emacs20 ;; [f8] C-h and C-x 8 C-h  :=  Help for [f8] and C-x 8 prefixes:
;;;@@@Emacs20 (global-set-key (vector 'f8 help-char) 'help-iso-prefix) ; In `help.el'.
;;;@@@Emacs20 (define-key ctl-x-map "8\C-h" 'help-iso-prefix) ; Defined in `help.el'.

;; These *declp* commands are defined in `misc-cmds.el'.
;(global-set-key [C-print] 'declp-buffer) ; Print buffer. (defsubst)
;(global-set-key [M-print] 'pr-declp-buffer) ; Print buffer via `pr'.
;(global-set-key [C-M-print] 'declp-buffer-w-switches) ; User `declp' switches.
;(global-set-key [S-print] 'transpose-paragraphs) ; Defined in `paragraphs.el'
;(global-set-key [C-S-print] 'declp-region) ; Print region. (defsubst)
;(global-set-key [M-S-print] 'pr-declp-region) ; Print region via `pr'.
;(global-set-key [C-M-S-print] 'declp-region-w-switches) ; `declp' + switches.

;; [home], [end], [prior], and [next] keys.  These are used, unmodified, by
;; `s-region-move', which is defined in `s-region+.el'.  The following commands,
;; except `forward-page' & `backward-page', are also defined in `s-region+.el'.
;(global-set-key [C-prior] 'backward-page) ; Defined in `page.el'.
;(global-set-key [C-previous] 'backward-page)
;(global-set-key [C-next] 'forward-page) ; Defined in `page.el'.
;(global-set-key [next] 'scroll-up-windowful) ; Defined in `s-region+.el'.
;(global-set-key [previous] 'scroll-down-windowful) ; Defined in `s-region+.el'.
;(global-set-key [prior] 'scroll-down-windowful)
;(global-set-key [M-next] 'scroll-other-window-up-windowful) ; In `s-region+.el'
;(global-set-key [M-previous] 'scroll-other-window-down-windowful)
;(global-set-key [M-prior] 'scroll-other-window-down-windowful) ; `s-region+.el'
;(global-set-key [home] 'goto-point-min) ; (defsubst) Defined in `s-region+.el'.
;(global-set-key [end] 'goto-point-max) ; (defsubst) Defined in `s-region+.el'.
;(global-set-key [M-home] 'bob-other-window) ; (defsubst) In `s-region+.el'.
;(global-set-key [M-end] 'eob-other-window) ; (defsubst) In `s-region+.el'.
;(s-region-bind (list [prior] [C-prior] [M-prior]))

(eval-after-load "swiss-move"
  '(progn
    (global-set-key [S-prior] 'swiss-move-line-up)                            ; `S-prior'
    (global-set-key [S-next]  'swiss-move-line-down)))                        ; `S-next'

;; [up], [down], [left], [right] keys.
(global-set-key [S-down] (lambda () (interactive) (scroll-up 1)))                  ; `S-down'
(global-set-key [S-up] (lambda () (interactive) (scroll-down 1)))                  ; `S-up'
;;(global-set-key [M-up] (lookup-key esc-map "p")) ; Probably not defined.
;;(global-set-key [M-down] (lookup-key esc-map "n")) ; Probably not defined.
;;(global-set-key [M-left] (lookup-key esc-map "b")) ; Predefined.
;;(global-set-key [M-right] (lookup-key esc-map "f")) ; Predefined.
(global-set-key [C-M-home] 'beginning-of-defun)                               ; `C-M-home'
(global-set-key [C-M-end] 'end-of-defun)                                      ; `C-M-end'

(eval-after-load "misc-cmds"
  '(progn
    (global-set-key "\M-p" 'back-to-indentation+)                             ; `M-p'
    (global-set-key "\M-n" 'forward-to-indentation+)))                        ; `M-n'

;;;-----------REPLACEMENT BINDINGS------------------------------------

(defvar sub-*-of-line t
  "*Non-nil means remap `*-of-line' commands to `*-of-line+' globally.
This applies to `move-to-(beginning|end)-of-line', if defined, or to
`(beginning|end)-of-line', otherwise.
This has no effect unless you use library `misc-cmds.el'.")

(defvar sub-clone-frame t
  "*Non-nil means remap `make-frame-command' to `clone-frame' globally.
This has no effect unless you use library `frame-cmds.el'.")

(defvar sub-delete-windows-for t
  "*Non-nil means remap `delete-window' to `delete-windows-for' globally.
This has no effect unless you use library `frame-cmds.el'.")

(defvar sub-kill-buffer-and-its-windows t
  "*Non-nil means remap `kill-buffer' to `kill-buffer-and-its-windows' globally.
This has no effect unless you use library `misc-cmds.el'.")

(defvar sub-pp-evals t
  "*Non-nil means remap `eval-*' commands to `pp-eval-*' globally.
Thus, `pp-eval-expression' replaces `eval-expression' and
`pp-eval-last-sexp' replaces `eval-last-sexp'.
This has no effect unless you use library `pp+.el'.")

(defvar sub-query-replace-w-options t
  "*Non-nil means remap `query-replace' to `query-replace-w-options' globally.
This has no effect unless you use library `replace+.el'.")

(defvar sub-quit-window-delete (fboundp 'quit-restore-window) ; Emacs 24.3+
  "*Non-nil means remap `quit-window' to `quit-window-delete' globally.
This has no effect unless you use library `misc-cmds.el' and Emacs
24.4 or later.")

(defvar sub-recenter-top-bottom t
  "*Non-nil means remap `recenter' to `sub-recenter-top-bottom' globally.
This has no effect unless you use library `misc-cmds.el'.")

(defvar sub-transpose-sexps t
  "*Non-nil means remap `transpose-sexps' to `reversible-transpose-sexps'.
This has no effect unless you use library `misc-cmds.el'.")


;;; Do these all *after* load `menu-bar+.el', since that sets original bindings.

(eval-after-load "frame-cmds"
  '(progn
    (when sub-delete-windows-for
      (remap-command 'delete-window 'delete-windows-for global-map))
    (when sub-clone-frame
      (remap-command 'make-frame-command 'clone-frame global-map))))
(eval-after-load "replace+"
  '(when sub-query-replace-w-options
    (remap-command 'query-replace 'query-replace-w-options global-map)))
(eval-after-load "misc-cmds"
  '(when sub-kill-buffer-and-its-windows
    (remap-command 'kill-buffer 'kill-buffer-and-its-windows global-map)))
(eval-after-load "pp+"
  '(when sub-pp-evals
    (remap-command 'eval-last-sexp 'pp-eval-last-sexp global-map)
    (remap-command 'eval-expression 'pp-eval-expression global-map)))
(when (fboundp 'buffer-menu)
  (remap-command 'list-buffers 'buffer-menu global-map)) ; In `buff-menu+.el'.
(eval-after-load "misc-cmds"
  '(progn
    (when sub-*-of-line
      (cond ((fboundp 'move-beginning-of-line)
             (remap-command 'move-beginning-of-line 'beginning-of-line+ global-map)
             (remap-command 'move-end-of-line 'end-of-line+ global-map))
            (t
             (remap-command 'beginning-of-line 'beginning-of-line+ global-map)
             (remap-command 'end-of-line 'end-of-line+ global-map)))
      (when (boundp 'visual-line-mode-map)
        (define-key visual-line-mode-map [remap move-beginning-of-line] nil)
        (define-key visual-line-mode-map [remap move-end-of-line]       nil)
        (define-key visual-line-mode-map [home] 'beginning-of-line+)
        (define-key visual-line-mode-map [end]  'end-of-line+)
        (define-key visual-line-mode-map "\C-a" 'beginning-of-visual-line+)
        (define-key visual-line-mode-map "\C-e" 'end-of-visual-line+)))
    (when sub-recenter-top-bottom
      (remap-command 'recenter 'recenter-top-bottom global-map))
    (when sub-transpose-sexps
      (remap-command 'transpose-sexps 'reversible-transpose-sexps global-map))))
(eval-after-load "misc-cmds"
  '(when sub-quit-window-delete
    (remap-command 'quit-window 'quit-window-delete global-map)))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'setup-keys)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; setup-keys.el ends here
#+end_src